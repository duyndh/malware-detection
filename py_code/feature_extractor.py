import numpy as np
import sys
import math

from const_container import *

class FeatureExtractor:

    @staticmethod
    def get_sequence_counts(graph, value_range, sequence_length, output_linear_array):

        counts = np.zeros(pow(value_range, sequence_length), np.int)

        for node in graph:

            if sequence_length == 1:
                counts[node["opcode"]] += 1
            elif sequence_length == 2:
                base_index = node["opcode"] * value_range
                for next_id in node["next"]:
                    next_node = graph[next_id]
                    counts[base_index + next_node["opcode"]] += 1
            else:
                pass

        if output_linear_array:
            return counts
        else:
            return counts.reshape(tuple([value_range for i in range(sequence_length)]))

    @staticmethod
    def extract_tf(graphs, value_range, sequence_length):

        tfs = []
        for graph in graphs:
            sequence_counts = FeatureExtractor.get_sequence_counts(graph, value_range, sequence_length, True)
            max_count = max(sequence_counts)
            tfs.append(np.array([(0.5 + 0.5 * (count / max_count)) for count in sequence_counts]))

        print(tfs[0].shape)
        return tfs

    @staticmethod
    def extract_tf_idf(graphs, value_range, sequence_length):

        sample_include_op_counts = np.zeros(pow(value_range, sequence_length), np.int)
        tfs = []
        for graph in graphs:
            sequence_counts = FeatureExtractor.get_sequence_counts(graph, value_range, sequence_length, True)
            max_count = max(sequence_counts)
            tfs.append(np.array([count / max_count for count in sequence_counts]))

            for op_index in range(len(sequence_counts)):
                if sequence_counts[op_index] > 0:
                    sample_include_op_counts[op_index] += 1

        idfs = [math.fabs(math.log(len(graphs) / (count + sys.float_info.epsilon)))
                for count in sample_include_op_counts]

        tf_idfs = []
        for tfs in tfs:
            tf_idf = []
            for tf_index in range(len(tfs)):
                tf_idf.append(tfs[tf_index] * idfs[tf_index])
            tf_idfs.append(tf_idf)

        return tf_idfs

    @staticmethod
    def internal_pagerank(M, num_iterations: int = 100, d: float = 0.85):
        N = M.shape[1]
        v = np.random.rand(N, 1)
        v = v / np.linalg.norm(v, 1)
        M_hat = (d * M + (1 - d) / N)
        for i in range(num_iterations):
            v = M_hat @ v
        return v

    @staticmethod
    def extract_pagerank(graphs, value_range):

        page_ranks = []
        for graph in graphs:
            sequence_2d_counts = FeatureExtractor.get_sequence_counts(graph, value_range, 2, False)
            weights = np.zeros((value_range, value_range), np.float)

            for src_id in range(value_range):

                dst_count = sum([sequence_2d_counts[src_id][dst_id] for dst_id in range(value_range)])
                for dst_id in range(value_range):
                    if dst_count > 0:
                        weights[src_id][dst_id] = sequence_2d_counts[src_id][dst_id] * 1.0 / dst_count
                    else:
                        weights[src_id][dst_id] = 0

            weights = weights.transpose()
            page_ranks.append(FeatureExtractor.internal_pagerank(weights).reshape(-1))

        print(page_ranks[0].shape)
        return page_ranks

    @staticmethod
    def extract_feature(method, graphs, value_range, sequence_length):

        if method == FeatureMethod.TF:
            return FeatureExtractor.extract_tf(graphs, value_range, sequence_length)
        elif method == FeatureMethod.TF_IDF:
            return FeatureExtractor.extract_tf_idf(graphs, value_range, sequence_length)
        elif method == FeatureMethod.PR:
            return FeatureExtractor.extract_pagerank(graphs, value_range)
        else:
            return None