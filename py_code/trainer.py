from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis as QDA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import LogisticRegression
from sklearn.cluster import KMeans
from sklearn.ensemble import GradientBoostingClassifier

from sklearn.decomposition import PCA

from const_container import *

class Trainer:

    @staticmethod
    def get_classifiers():
        return {
            "Nearest Neighbors": KNeighborsClassifier(3),
            "Linear SVM": SVC(kernel="linear", C=0.025),
            "RBF SVM": SVC(gamma=2, C=1),
            "Decision Tree": DecisionTreeClassifier(max_depth=5),
            "Random Forest": RandomForestClassifier(max_depth=5, n_estimators=10, max_features=1),
            "Neural Net": MLPClassifier(alpha=1, max_iter=1000),
            "Naive Bayes": GaussianNB(),
            "QDA": QDA(),
            "LDA": LDA(),
            "Linear Regression": LinearRegression(),
            "Logistic Regression": LogisticRegression(random_state=0, max_iter=1000),
            "KMeans": KMeans(n_clusters=2, random_state=0),
            "AdaBoost": AdaBoostClassifier(),
            "Gradient Boosting": GradientBoostingClassifier(random_state=0),
        }

    @staticmethod
    def internal_train(classifier, X_train, y_train, X_test):

        # fit model
        classifier.fit(X_train, y_train)

        # calculate accuracy
        predicts = classifier.predict(X_test)

        return [(1 if int(round(x)) > 0 else 0) for x in predicts]

    @staticmethod
    def init_train(X, y, reduce_dimension):

        print("Initializing...")

        # create scaler
        sc = StandardScaler()

        # split to train and test set
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=TEST_RATIO, random_state=42)

        # normalize
        X_train = sc.fit_transform(X_train)
        X_test = sc.transform(X_test)

        # reduce number of dimension
        pca = PCA(n_components=REDUCED_FEATURE_SIZE)
        X_train_pca = pca.fit_transform(X_train)
        X_test_pca = pca.transform(X_test)

        if len(X_train[0]) > MAX_FEATURE_SIZE:
            pca = PCA(n_components=MAX_FEATURE_SIZE)
            X_train = pca.fit_transform(X_train)
            X_test = pca.transform(X_test)

        print("default feature size=", len(X_train[0]))
        print("reduced feature size=", len(X_train_pca[0]))

        return X_train, y_train, X_test, y_test, X_train_pca, X_test_pca

    @staticmethod
    def single_train(classifier_name, X_train, y_train, X_test):

        # get classifiers
        classifiers = Trainer.get_classifiers()

        # train
        predicts = Trainer.internal_train(classifiers[classifier_name], X_train, y_train, X_test)

        return predicts

    @staticmethod
    def cross_train(X_train, y_train, X_test, X_train_pca, X_test_pca):

        print("Cross training...")

        print("n train:", len(X_train))
        print("n test:", len(X_test))

        # get classifiers
        classifiers = Trainer.get_classifiers()

        cross_predicts = []

        # iterate over classifiers
        for classifier_name in classifiers:

            print(classifier_name, end=" ")

            # train
            if classifier_name == "LDA" or classifier_name == "QDA" or classifier_name == "Logistic Regression":
                print("feature size=", len(X_train_pca[0]))
                cross_predicts.append(Trainer.internal_train(classifiers[classifier_name],
                                                                 X_train_pca, y_train, X_test_pca))
            else:
                print("feature size=", len(X_train[0]))
                cross_predicts.append(Trainer.internal_train(classifiers[classifier_name],
                                                                 X_train, y_train, X_test))

            pass

        return cross_predicts

