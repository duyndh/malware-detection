#include "pch.h"
#include "Disassembler.h"

#include "Wrapper.h"

bool Disassembler::GetCodeSectionData()
{
	bool result = false;
	do
	{
		if (m_file_data.empty())
			break;

		LPBYTE file_data_ptr = (LPBYTE)m_file_data.data();
		LPBYTE file_end_ptr = file_data_ptr + m_file_data.size();

		// dos header
		PIMAGE_DOS_HEADER dos_header_ptr = (PIMAGE_DOS_HEADER)file_data_ptr;
		if ((LPBYTE)dos_header_ptr >= file_end_ptr)
			break;

		// is pe
		if (dos_header_ptr->e_magic != 0x5a4d)
			break;

		// nt headers
		PIMAGE_NT_HEADERS nt_headers_ptr = (PIMAGE_NT_HEADERS)((LPBYTE)file_data_ptr + dos_header_ptr->e_lfanew);
		if ((LPBYTE)nt_headers_ptr >= file_end_ptr)
			break;

		// file header
		PIMAGE_FILE_HEADER file_header_ptr = (PIMAGE_FILE_HEADER)((LPBYTE)nt_headers_ptr + sizeof(dos_header_ptr->e_lfanew));
		if ((LPBYTE)file_header_ptr >= file_end_ptr)
			break;

		// is x86
		if (file_header_ptr->Machine != 0x14c)
			break;

		// optional header
		PIMAGE_OPTIONAL_HEADER32 optional_header_ptr = (PIMAGE_OPTIONAL_HEADER32)((LPBYTE)file_header_ptr + sizeof(IMAGE_FILE_HEADER));
		if ((LPBYTE)optional_header_ptr >= file_end_ptr)
			break;

		// section header
		PIMAGE_SECTION_HEADER image_section_header_ptr = (PIMAGE_SECTION_HEADER)((LPBYTE)optional_header_ptr + sizeof(IMAGE_OPTIONAL_HEADER32));
		if ((LPBYTE)image_section_header_ptr >= file_end_ptr)
			break;

		// browse each section
		for (int section_index = 0; section_index < file_header_ptr->NumberOfSections; section_index++)
		{
			std::string section_name_str = (LPSTR)image_section_header_ptr->Name;

			// is code section
			if (section_name_str.find("text") != section_name_str.npos || section_name_str.find("code") != section_name_str.npos)
			{
				if (image_section_header_ptr->PointerToRawData && image_section_header_ptr->Misc.VirtualSize)
				{
					m_shellcode_data_ptr = file_data_ptr + image_section_header_ptr->PointerToRawData;
					m_shellcode_data_size = image_section_header_ptr->Misc.VirtualSize;
					break;
				}
			}

			image_section_header_ptr++;
		}

		if (!m_shellcode_data_ptr || !m_shellcode_data_size)
			break;

		result = true;
	} while (false);

	return result;
}

bool Disassembler::Disassembly()
{
	cs_insn* inst_arr = NULL;
	size_t inst_count = 0;

	bool result = false;
	do
	{
		// disasm
		inst_count = cs_disasm(m_cs_handle, m_shellcode_data_ptr, m_shellcode_data_size, 0, 0, &inst_arr);
		for (size_t inst_index = 0; inst_index < inst_count; inst_index++)
		{
			// current inst
			auto inst_ptr = &inst_arr[inst_index];
			auto x86_inst_ptr = &inst_ptr->detail->x86;

			// address
			DWORD64 address_qw = inst_ptr->address;

			// opcode
			BYTE opcode = x86_inst_ptr->opcode[0];

			// opname
			std::string opname = inst_ptr->mnemonic;

			// operands
			std::list<BYTE> registers;
			std::list<DWORD64> immediates;
			std::list<BYTE> memories;

			for (size_t operand_index = 0; operand_index < x86_inst_ptr->op_count; operand_index++)
			{
				auto operand_ptr = &(x86_inst_ptr->operands[operand_index]);

				switch ((int)operand_ptr->type) {
					
					// register
				case X86_OP_REG:
					registers.push_back(operand_ptr->reg);
					break;
					
					// immediate
				case X86_OP_IMM:
					immediates.push_back(operand_ptr->imm);
					break;
					
					// memory
				case X86_OP_MEM:
					if (operand_ptr->mem.segment != X86_REG_INVALID)
						memories.push_back(operand_ptr->mem.segment);
					else
					{
						if (operand_ptr->mem.base != X86_REG_INVALID)
							memories.push_back(operand_ptr->mem.base);

						if (operand_ptr->mem.index != X86_REG_INVALID)
							memories.push_back(operand_ptr->mem.index);
					}

					break;
				default:
					break;
				}
			}

			m_instructions.push_back(std::make_tuple(address_qw, opcode, opname, registers, immediates, memories));
		}

		result = true;
		
	} while (false);

	// clean up
	cs_free(inst_arr, inst_count);

	return result;
}

Disassembler::Disassembler()
{
	// open cs m_cs_handle
	cs_err err = cs_open(CS_ARCH_X86, CS_MODE_32, &m_cs_handle);
	if (!err)
	{
		// require detail option
		cs_option(m_cs_handle, CS_OPT_DETAIL, CS_OPT_ON);
	}
}

Disassembler::~Disassembler()
{
	cs_close(&m_cs_handle);
}

bool Disassembler::Disassembly(const std::string& major_file_path_str, const std::string& minor_file_path_str)
{
	/*if (minor_file_path_str.empty())
	{		
	}*/

	bool result = false;
	do
	{	
		if (!Wrapper::ReadFileData(major_file_path_str, m_file_data))
			break;

		
		if (!GetCodeSectionData())
			break;

		std::list<std::tuple<DWORD64, BYTE, std::string, std::list<BYTE>, std::list<DWORD64>, std::list<BYTE>>> instructions;
		if (!Disassembly())
			break;

		result = true;
		
	} while (false);

	return result;
}

void Disassembler::Export(const std::string output_file_path_str)
{
	std::ofstream file_stream(output_file_path_str);

	do
	{
		//csv header
		file_stream << "A,O,N,R,I,M" << std::endl;

		for (auto& inst : m_instructions)
		{
			file_stream << std::hex << std::get<0>(inst) << ',';
			file_stream << std::hex << (DWORD)std::get<1>(inst) << ',';
			file_stream << std::get<2>(inst) << ',';

			// registers
			auto &registers = std::get<3>(inst);
			bool have_reg = false;
			for (auto& reg : registers)
			{
				if (have_reg)
					file_stream << ' ';
				file_stream << cs_reg_name(m_cs_handle, reg);
				have_reg = true;
			}

			file_stream << ',';

			// imm
			auto& imms = std::get<4>(inst);
			bool have_imm = false;
			for (auto& imm : imms)
			{
				if (have_imm)
					file_stream << ' ';
				file_stream << imm;
				have_imm = true;
			}
			
			file_stream << ',';

			// memory
			auto memories = std::get<5>(inst);
			bool have_mem = false;
			for (auto& mem : memories)
			{
				if (have_mem)
					file_stream << ' ';
				file_stream << cs_reg_name(m_cs_handle, mem);
				have_mem = true;
			}
			
			file_stream << std::endl;
		}
	
	} while (false);

	file_stream.close();
}
