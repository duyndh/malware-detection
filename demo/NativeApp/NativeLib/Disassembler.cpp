#include "pch.h"
#include "Disassembler.h"

#include "Wrapper.h"

bool Disassembler::GetCodeSectionDataFromPe()
{
	bool result = false;
	do
	{
		if (m_pe_file_data.empty())
			break;

		LPBYTE file_data_ptr = (LPBYTE)m_pe_file_data.data();
		LPBYTE file_end_ptr = file_data_ptr + m_pe_file_data.size();

		// dos header
		PIMAGE_DOS_HEADER dos_header_ptr = (PIMAGE_DOS_HEADER)file_data_ptr;
		if ((LPBYTE)dos_header_ptr >= file_end_ptr)
			break;

		// is pe
		if (dos_header_ptr->e_magic != 0x5a4d)
			break;

		// nt headers
		PIMAGE_NT_HEADERS nt_headers_ptr = (PIMAGE_NT_HEADERS)((LPBYTE)file_data_ptr + dos_header_ptr->e_lfanew);
		if ((LPBYTE)nt_headers_ptr >= file_end_ptr)
			break;

		// file header
		PIMAGE_FILE_HEADER file_header_ptr = (PIMAGE_FILE_HEADER)((LPBYTE)nt_headers_ptr + sizeof(dos_header_ptr->e_lfanew));
		if ((LPBYTE)file_header_ptr >= file_end_ptr)
			break;

		// is x86
		if (file_header_ptr->Machine != 0x14c)
			break;

		// optional header
		PIMAGE_OPTIONAL_HEADER32 optional_header_ptr = (PIMAGE_OPTIONAL_HEADER32)((LPBYTE)file_header_ptr + sizeof(IMAGE_FILE_HEADER));
		if ((LPBYTE)optional_header_ptr >= file_end_ptr)
			break;

		// section header
		PIMAGE_SECTION_HEADER image_section_header_ptr = (PIMAGE_SECTION_HEADER)((LPBYTE)optional_header_ptr + sizeof(IMAGE_OPTIONAL_HEADER32));
		if ((LPBYTE)image_section_header_ptr >= file_end_ptr)
			break;

		// browse each section
		for (int section_index = 0; section_index < file_header_ptr->NumberOfSections; section_index++)
		{
			std::string section_name_str = (LPSTR)image_section_header_ptr->Name;

			// is code section
			if (section_name_str.find("text") != std::string::npos || section_name_str.find("code") != std::string::npos)
			{
				if (image_section_header_ptr->PointerToRawData && image_section_header_ptr->Misc.VirtualSize)
				{
					m_shellcode_virtual_address_in_pe_file = image_section_header_ptr->PointerToRawData;
					m_shellcode_size = image_section_header_ptr->Misc.VirtualSize;
					break;
				}
			}

			image_section_header_ptr++;
		}

		if (!m_shellcode_virtual_address_in_pe_file || !m_shellcode_size)
			break;

		result = true;
	} while (false);

	return result;
}

bool Disassembler::GetMetaDataFromAsm(const std::string& asm_file_path_str)
{
	std::ifstream file_stream(asm_file_path_str, std::ios::binary);
	std::string line_str;

	bool result = false;
	bool is_pe = false;
	do
	{
		while (std::getline(file_stream, line_str))
		{
			if (!is_pe)
			{
				// found format
				size_t format_pos = line_str.find("Format");
				if (format_pos != std::string::npos)
				{
					// found (PE) && 80386
					if (line_str.find("(PE)", format_pos) != std::string::npos && line_str.find("80386", format_pos) != std::string::npos)
					{
						is_pe = true;
					}

					// not PE
					if (!is_pe)
					{
						break;
					}
				}
			}

			if (!m_image_base)
			{
				size_t img_base_pos = line_str.find("Imagebase");
				// found imagebase
				if (img_base_pos != std::string::npos)
				{
					auto parts = Wrapper::Split(line_str.substr(img_base_pos), "", true);
					for (auto& part : parts)
					{
						if (Wrapper::CheckHexString(part))
						{
							m_image_base = std::stoull(part, NULL, 16);
							break;
						}
					}

					// Invalid image base
					if (!m_image_base)
						break;
				}
			}

			if (is_pe && m_image_base)
				break;
		}

		if (!is_pe || !m_image_base)
			break;
		
		result = true;
	} while (false);

	file_stream.close();

	return result;
}

bool Disassembler::GetTextSectionInfoFromAsm(const std::vector<std::string>& lines, DWORD64 &virtual_address, DWORD &virtual_size)
{
	virtual_address = 0;
	virtual_size = 0;

	bool is_text_section = false;
	
	bool result = false;
	do
	{
		for (auto& line_str : lines)
		{
			// virtual address
			if (!virtual_address)
			{
				size_t virtual_address_pos = line_str.find("virtual address");
				if (virtual_address_pos != std::string::npos)
				{
					auto parts = Wrapper::Split(line_str.substr(virtual_address_pos), "", true);
					for (auto& part : parts)
					{
						if (Wrapper::CheckHexString(part))
						{
							virtual_address = std::stoull(part, NULL, 16);
							break;
						}
					}
					if (!virtual_address)
						break;
				}
			}

			// virtual size
			if (!virtual_size)
			{
				size_t virtual_size_pos = line_str.find("Virtual size");
				if (virtual_size_pos != std::string::npos)
				{
					auto parts = Wrapper::Split(line_str.substr(virtual_size_pos), "", true);
					for (auto& part : parts)
					{
						if (Wrapper::CheckHexString(part))
						{
							virtual_size = std::stoull(part, NULL, 16);
							break;
						}
					}
					if (!virtual_size)
						break;
				}
			}

			// is text section
			if (!is_text_section)
			{
				size_t flags_pos = line_str.find("Flags");
				if (flags_pos != std::string::npos)
				{
					if (line_str.find("Text Executable Readable", flags_pos) != std::string::npos)
						is_text_section = true;
					else
						break;
				}
			}
		}

		if (!is_text_section || !virtual_address || !virtual_size)
			break;
		
		result = true;
	} while (false);

	return result;
}

bool Disassembler::GetCodeSectionDataFromAsm(const std::string& asm_file_path_str)
{
	std::ifstream file_stream(asm_file_path_str, std::ios::binary);
	std::string line_str;

	bool result = false;
	do
	{
		while (std::getline(file_stream, line_str))
		{
			size_t section_pos = line_str.find("Section");

			// found section
			if (section_pos != std::string::npos)
			{
				// prepare lines
				std::vector<std::string> sub_lines;
				sub_lines.reserve(6);
				std::string sub_line_str;
				sub_lines.push_back(line_str);
				while (std::getline(file_stream, sub_line_str) && sub_lines.size() < sub_lines.capacity())
					sub_lines.push_back(sub_line_str);

				DWORD64 virtual_address = 0;
				DWORD virtual_size = 0;
				
				// get text section
				if (GetTextSectionInfoFromAsm(sub_lines, virtual_address, virtual_size))
				{
					m_code_section_virtual_address = virtual_address;
					m_shellcode_size = virtual_size;
					break;
				}
			}
		}

		if (!m_code_section_virtual_address || !m_shellcode_size)
			break;
			
		result = true;
	} while (false);
	
	file_stream.close();

	return result;
}

bool Disassembler::GetCodeFromBytes(const std::string& bytes_file_path_str)
{
	// open file
	std::ifstream file_stream(bytes_file_path_str);

	DWORD64 beginAddress = m_image_base + m_code_section_virtual_address;
	DWORD64 endAddress = beginAddress + m_shellcode_size;

	m_pe_file_data.resize(m_shellcode_size);
	
	bool result = false;
	DWORD offset = 0;
	do
	{
		std::string line_str;
		while (std::getline(file_stream, line_str))
		{
			auto parts = Wrapper::Split(line_str);
			if (parts.empty())
				continue;

			if (!Wrapper::CheckHexString(parts.front()))
				continue;

			DWORD64 address = std::stoull(parts.front(), NULL, 16);
			if (address < beginAddress)
				continue;
			if (address >= endAddress)
				break;

			offset = address - beginAddress;			
			for (auto it = std::next(parts.begin()); it != parts.end() && offset < m_pe_file_data.size(); it++, offset++)
			{
				BYTE b = 0;
				if (Wrapper::CheckHexString(*it))
				{
					b = std::stoi(*it, NULL, 16);
				}

				m_pe_file_data[offset] = b;
			}
		}

		result = true;
	} while (false);

	file_stream.close();
	
	return result;
}

bool Disassembler::InternalDisassembly()
{
	cs_insn* inst_arr = NULL;
	size_t inst_count = 0;

	bool result = false;
	do
	{
		LPBYTE shellcode_ptr = m_pe_file_data.data() + m_shellcode_virtual_address_in_pe_file;
		
		// disasm
		inst_count = cs_disasm(m_cs_handle, shellcode_ptr, m_shellcode_size, m_image_base + m_code_section_virtual_address, 0, &inst_arr);
		for (size_t inst_index = 0; inst_index < inst_count; inst_index++)
		{
			// current inst
			auto inst_ptr = &inst_arr[inst_index];
			auto x86_inst_ptr = &inst_ptr->detail->x86;

			// address
			DWORD64 address = inst_ptr->address;

			// op_code
			BYTE opcode = x86_inst_ptr->opcode[0];

			// opname
			std::string opname = inst_ptr->mnemonic;

			// operands
			std::list<BYTE> registers;
			std::list<DWORD64> immediates;
			std::list<BYTE> memories;

			for (size_t operand_index = 0; operand_index < x86_inst_ptr->op_count; operand_index++)
			{
				auto operand_ptr = &(x86_inst_ptr->operands[operand_index]);

				switch ((int)operand_ptr->type) {
					
					// register
				case X86_OP_REG:
					registers.push_back(operand_ptr->reg);
					break;
					
					// immediate
				case X86_OP_IMM:
					immediates.push_back(operand_ptr->imm);
					break;
					
					// memory
				case X86_OP_MEM:
					if (operand_ptr->mem.segment != X86_REG_INVALID)
						memories.push_back(operand_ptr->mem.segment);
					else
					{
						if (operand_ptr->mem.base != X86_REG_INVALID)
							memories.push_back(operand_ptr->mem.base);

						if (operand_ptr->mem.index != X86_REG_INVALID)
							memories.push_back(operand_ptr->mem.index);
					}

					break;
				default:
					break;
				}
			}

			m_instructions.push_back(std::make_tuple(address, opcode, opname, registers, immediates, memories));
		}

		result = true;
		
	} while (false);

	// clean up
	cs_free(inst_arr, inst_count);

	return result;
}

Disassembler::Disassembler()
{
	// open cs m_cs_handle
	cs_err err = cs_open(CS_ARCH_X86, CS_MODE_32, &m_cs_handle);
	if (!err)
	{
		// require detail option
		cs_option(m_cs_handle, CS_OPT_DETAIL, CS_OPT_ON);
	}
}

Disassembler::~Disassembler()
{
	cs_close(&m_cs_handle);
}

bool Disassembler::Disassembly(const std::string& input_file_path_str, const std::string& asm_file_path_str)
{
	bool result = false;
	do
	{	
		
		if (asm_file_path_str.empty())
		{
			if (!Wrapper::ReadFileData(input_file_path_str, m_pe_file_data))
				break;

			if (!GetCodeSectionDataFromPe())
				break;
		}
		else
		{
			if (!GetMetaDataFromAsm(asm_file_path_str))
				break;

			if (!GetCodeSectionDataFromAsm(asm_file_path_str))
				break;
			
			if (!GetCodeFromBytes(input_file_path_str))
				break;
		}
		
		std::list<std::tuple<DWORD64, BYTE, std::string, std::list<BYTE>, std::list<DWORD64>, std::list<BYTE>>> instructions;
		if (!InternalDisassembly())
			break;

		result = true;
		
	} while (false);

	return result;
}

void Disassembler::Export(const std::string output_file_path_str)
{
	std::ofstream file_stream(output_file_path_str);

	do
	{
		//csv header
		file_stream << "A,O,N,R,I,M" << std::endl;

		for (auto& inst : m_instructions)
		{
			file_stream << std::hex << std::get<0>(inst) << ',';
			file_stream << std::hex << (DWORD)std::get<1>(inst) << ',';
			file_stream << std::get<2>(inst) << ',';

			// registers
			auto &registers = std::get<3>(inst);
			bool have_reg = false;
			for (auto& reg : registers)
			{
				if (have_reg)
					file_stream << ' ';
				file_stream << cs_reg_name(m_cs_handle, reg);
				have_reg = true;
			}

			file_stream << ',';

			// imm
			auto& imms = std::get<4>(inst);
			bool have_imm = false;
			for (auto& imm : imms)
			{
				if (have_imm)
					file_stream << ' ';
				file_stream << imm;
				have_imm = true;
			}
			
			file_stream << ',';

			// memory
			auto memories = std::get<5>(inst);
			bool have_mem = false;
			for (auto& mem : memories)
			{
				if (have_mem)
					file_stream << ' ';
				file_stream << cs_reg_name(m_cs_handle, mem);
				have_mem = true;
			}
			
			file_stream << std::endl;
		}
	
	} while (false);

	file_stream.close();
}
