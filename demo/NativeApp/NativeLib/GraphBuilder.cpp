#include "pch.h"
#include "GraphBuilder.h"

void GraphBuilder::SetDirectPrevForTraceStack(std::stack<DWORD>& trace_stack, DWORD index)
{
	if (!trace_stack.empty())
	{
		trace_stack.pop();

		while (!trace_stack.empty())
		{
			m_instructions[trace_stack.top()].direct_prev_index = index;
			trace_stack.pop();
		}
	}

	// open cs m_cs_handle
	cs_err err = cs_open(CS_ARCH_X86, CS_MODE_32, &m_cs_handle);
	if (!err)
	{
		// require detail option
		cs_option(m_cs_handle, CS_OPT_DETAIL, CS_OPT_ON);
	}
}

void GraphBuilder::TraceCall(DWORD ret_index, DWORD index, std::stack<DWORD>& trace_stack, std::set<DWORD>& traveled_index_set, bool tracing)
{
	InstructionNode* instruction_node_ptr = &m_instructions[index];

	trace_stack.push(index);
	if (traveled_index_set.find(index) != traveled_index_set.end())
	{
		if (tracing)
			SetDirectPrevForTraceStack(trace_stack, index);
	}
	else
	{
		traveled_index_set.insert(index);

		if (instruction_node_ptr->direct_prev_index != MAXDWORD32)
		{
			TraceCall(ret_index, instruction_node_ptr->direct_prev_index, trace_stack, traveled_index_set, false);
		}
		else
		{
			// meet call instruction
			if (instruction_node_ptr->op_name.find("call") != std::string::npos)
			{
				if (tracing)
					SetDirectPrevForTraceStack(trace_stack, index);

				if (index + 1 < m_instructions.size())
				{
					// link next of ret is call
					m_instructions[ret_index].next_ret_index_set.insert(index + 1);
					m_instructions[index + 1].prev_ret_index_set.insert(ret_index);
				}
			}
			// no more prev
			else if (!instruction_node_ptr->prev_index_set.size())
			{
				if (tracing)
					SetDirectPrevForTraceStack(trace_stack, index);
			}
			// linear
			else if (instruction_node_ptr->prev_index_set.size() == 1)
			{
				// Trace prev
				TraceCall(ret_index, *instruction_node_ptr->prev_index_set.begin(), trace_stack, traveled_index_set, tracing);
			}
			// multiple prev nodes
			else
			{
				if (tracing)
					SetDirectPrevForTraceStack(trace_stack, index);

				// Trace each prev node
				for (DWORD dwPrevIndex : instruction_node_ptr->prev_index_set)
				{
					// Trace prev
					TraceCall(ret_index, dwPrevIndex, trace_stack, traveled_index_set, tracing);
				}
			}
		}
	}

	if (!trace_stack.empty() && trace_stack.top() == index)
		trace_stack.pop();
}

void GraphBuilder::LinkJumps()
{
	DWORD64 min_known_address = 0;
	DWORD64 max_known_address = 0;
	{
		std::vector<InstructionNode>::iterator it = m_instructions.begin();
		for (size_t index = 0; index < m_unknown_nodes_count; index++)
			it = std::next(it);

		min_known_address = it->address;
		max_known_address = m_instructions.back().address;
	}
	
	// link
	for (size_t instruction_index = 0; instruction_index < m_instructions.size(); instruction_index++)
	{
		InstructionNode* node_ptr = &m_instructions[instruction_index];

		if (node_ptr->op_name.empty())
			continue;

		DWORD jump_index = 0;

		// imm
		if (!node_ptr->immediates_operands.empty())
		{
			DWORD64 imm = node_ptr->immediates_operands.front();

			// in range
			if (imm >= min_known_address && imm <= max_known_address)
			{
				// valid addr
				if (m_address_to_index_map.find(imm) != m_address_to_index_map.end())
				{
					jump_index = m_address_to_index_map.at(imm);
				}
				// invalid addr
				else
				{
					jump_index = 0;
				}
			}
			// out of range
			else
			{
				jump_index = 0;
			}
		}
		// registers
		else if (!node_ptr->register_operands.empty())
		{
			ConstantsContainer::RegisterType reg = node_ptr->register_operands.front();
			jump_index = min(m_unknown_nodes_count, (DWORD)reg);
		}
		// memory
		else if (!node_ptr->memory_operands.empty())
		{
			ConstantsContainer::RegisterType reg = node_ptr->memory_operands.front();
			jump_index = min(m_unknown_nodes_count, (DWORD)reg);
		}

		// next instruction address
		DWORD next_index = MAXDWORD32;
		if (instruction_index + 1 < m_instructions.size())
		{
			next_index = instruction_index + 1;
		}

		// jump
		if (node_ptr->op_name.front() == 'j')
		{
			// add jump address
			node_ptr->next_index_set.insert(jump_index);
			m_instructions[jump_index].prev_index_set.insert(instruction_index);

			// add next address
			if (node_ptr->op_name != "jmp" && next_index != MAXDWORD32 && next_index != jump_index)
			{
				node_ptr->next_index_set.insert(next_index);
				m_instructions[next_index].prev_index_set.insert(instruction_index);
			}
		}
		// call
		else if (node_ptr->op_name.find("call") != std::string::npos)
		{
			// add jump address
			node_ptr->next_index_set.insert(jump_index);
			m_instructions[jump_index].prev_index_set.insert(instruction_index);
		}
		// ret
		else if (node_ptr->op_name.find("ret") != std::string::npos)
		{
			// later
			m_ret_index_set.insert(instruction_index);
		}
		// linear
		else
		{
			if (next_index != MAXDWORD32)
			{
				node_ptr->next_index_set.insert(next_index);
				m_instructions[next_index].prev_index_set.insert(instruction_index);
			}
		}
	}
}

void GraphBuilder::LinkRets()
{
	for (auto& ret_index : m_ret_index_set)
	{
		std::stack<DWORD> stkTrace;
		std::set<DWORD> setTraveledIndex;

		TraceCall(ret_index, ret_index, stkTrace, setTraveledIndex, true);
	}
}

void GraphBuilder::MergeRetLinking()
{
	for (auto& node : m_instructions)
	{
		if (!node.next_ret_index_set.empty())
		{
			node.next_index_set.insert(node.next_ret_index_set.begin(), node.next_ret_index_set.end());
			node.next_ret_index_set.clear();
		}

		if (!node.prev_ret_index_set.empty())
		{
			node.prev_index_set.insert(node.prev_ret_index_set.begin(), node.prev_ret_index_set.end());
			node.prev_ret_index_set.clear();
		}
	}
}

GraphBuilder::GraphBuilder()
{
	// init unknown nodes
	m_unknown_nodes_count = 0;
	for (size_t reg_index = 0; reg_index < ConstantsContainer::RegisterType::RegisterType_Count; reg_index++)
	{
		DWORD64 unknown_node_address = MAXDWORD64 - reg_index;
		InstructionNode unknown_node(unknown_node_address);
		m_address_to_index_map[unknown_node_address] = m_instructions.size();
		m_instructions.push_back(unknown_node);
		m_unknown_nodes_count++;
	}
}

GraphBuilder::~GraphBuilder()
{
}

bool GraphBuilder::LoadInstructions(const std::string input_file_path_str)
{
	// open file
	std::ifstream file_stream(input_file_path_str);
	std::string line_str;

	// skip header
	std::getline(file_stream, line_str);

	bool result = false;
	do
	{
		// content
		while (std::getline(file_stream, line_str))
		{
			// to lower
			Wrapper::ToLowerString(line_str);
			
			// split csv line
			auto parts = Wrapper::Split(line_str, ",", false, true);
			if (parts.size() != 6)
				break;

			auto it = parts.begin();
			InstructionNode node;

			// address
			if (!Wrapper::CheckHexString(*it))
				break;
			node.address = std::stoull(*it, NULL, 16);
			it = std::next(it);

			// op code
			if (!Wrapper::CheckHexString(*it))
				break;
			node.op_code = std::stoull(*it, NULL, 16);
			it = std::next(it);

			// op name
			node.op_name = *it;
			it = std::next(it);

			// registers
			auto raw_operands = Wrapper::Split(*it, " ");
			for (auto& op : raw_operands)
			{
				if (ConstantsContainer::REGISTER_NAMES_MAP.find(op) != ConstantsContainer::REGISTER_NAMES_MAP.end())
					node.register_operands.push_back(ConstantsContainer::REGISTER_NAMES_MAP.at(op));
				else
					node.register_operands.push_back(ConstantsContainer::RegisterType::Register_Unknown);
			}
			if (node.register_operands.size() != raw_operands.size())
				break;
			it = std::next(it);

			// immediates
			raw_operands = Wrapper::Split(*it, " ");
			for (auto& op : raw_operands)
			{
				if (Wrapper::CheckHexString(op))
					node.immediates_operands.push_back(std::stoull(op, NULL, 16));
				else
					break;
			}
			if (node.immediates_operands.size() != raw_operands.size())
				break;
			it = std::next(it);

			// memories
			raw_operands = Wrapper::Split(*it, " ");
			for (auto& op : raw_operands)
			{
				if (ConstantsContainer::REGISTER_NAMES_MAP.find(op) != ConstantsContainer::REGISTER_NAMES_MAP.end())
					node.memory_operands.push_back(ConstantsContainer::REGISTER_NAMES_MAP.at(op));
				else
					node.memory_operands.push_back(ConstantsContainer::RegisterType::Register_Unknown);
			}
			if (node.memory_operands.size() != raw_operands.size())
				break;
			it = std::next(it);
			
			// Insert
			m_address_to_index_map[node.address] = m_instructions.size();
			m_instructions.push_back(node);
		}

		if (std::getline(file_stream, line_str))
			break;

		result = true;
	} while (false);

	// close file
	file_stream.close();

	return result;
}

void GraphBuilder::BuildGraph()
{
	do
	{
		// link jumps
		LinkJumps();

		// link rets
		LinkRets();

		// Merge ret linking
		MergeRetLinking();
	
	} while (false);

	return;
}

void GraphBuilder::Export(const std::string output_file_path_str)
{
	std::ofstream file_stream(output_file_path_str);

	do
	{
		//csv header
		file_stream << "O,N,R,M,D" << std::endl;

		for (auto& inst : m_instructions)
		{
			file_stream << std::hex << (DWORD)inst.op_code << ',';
			file_stream << inst.op_name << ',';

			// registers
			bool have_reg = false;
			for (auto& reg : inst.register_operands)
			{
				if (have_reg)
					file_stream << ' ';
				file_stream << std::hex << (DWORD)reg;
				have_reg = true;
			}

			file_stream << ',';

			// memory
			bool have_mem = false;
			for (auto& mem : inst.memory_operands)
			{
				if (have_mem)
					file_stream << ' ';
				file_stream << std::hex << (DWORD)mem;
				have_mem = true;
			}

			file_stream << ',';
			
			// next
			bool have_next = false;
			for (auto next_index : inst.next_index_set)
			{
				if (have_next)
					file_stream << ' ';
				file_stream << std::hex << next_index;
				have_next = true;
			}

			file_stream << std::endl;
		}

	} while (false);

	file_stream.close();
}
