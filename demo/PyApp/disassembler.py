import pefile
from capstone import *

class DisAssembler:

    @staticmethod
    def extract_opcodes_from_pe(pe_file_path):

        # Parse exe file
        pe = pefile.PE(pe_file_path)

        # Get code section
        if pe.OPTIONAL_HEADER.SizeOfCode == 0:
            return None
        section_addresses = []
        for section in pe.sections:
            section_addresses.append(section.VirtualAddress)

        base_of_code = pe.OPTIONAL_HEADER.BaseOfCode
        if base_of_code in section_addresses:
            code_section = pe.sections[section_addresses.index(base_of_code)]
        else:
            section_addresses.append(base_of_code)
            section_addresses.sort()
            if section_addresses.index(base_of_code) != 0:
                code_section = pe.sections[section_addresses.index(base_of_code) - 1]
            else:
                return None

        # Create capstone engine
        mode = 0
        if pe.FILE_HEADER.Machine == 0x8664:
            mode = CS_MODE_64
        elif pe.FILE_HEADER.Machine == 0x14c:
            mode = CS_MODE_32
        else:
            return None
        engine = Cs(CS_ARCH_X86, mode)

        instructions = []
        engine.detail = True
        last_address = 0
        last_size = 0

        # Get instructions
        begin = code_section.PointerToRawData
        end = begin + code_section.SizeOfRawData
        while True:
            data = pe.get_memory_mapped_image()[begin:end]
            for inst in engine.disasm(data, begin):
                address = hex(inst.address)
                op_name = inst.mnemonic
                op_code = hex(inst.opcode[0])
                operands = inst.op_str.replace(",", " ")

                instructions.append((address, op_name, op_code, operands))

                last_address = inst.address
                last_size = inst.size

            begin = max(int(last_address), begin) + last_size + 1
            if begin >= end:
                break

        return instructions

