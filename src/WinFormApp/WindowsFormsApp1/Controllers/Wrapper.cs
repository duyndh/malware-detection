using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Management;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using static WindowsFormsApp1.Controllers.Storage;
using static WindowsFormsApp1.Controls.MiningUserControl;

namespace WindowsFormsApp1.Controllers
{
    class Wrapper
    {
        public static string ConvertToAlphaNumString(string inputStr)
        {
            return Regex.Replace(inputStr, "[^a-zA-Z0-9]+", "_");
        }

        public static string CalculateFileHash(string filePath)
        {
            using (var sha256 = SHA256.Create())
            {
                using (var stream = File.OpenRead(filePath))
                {
                    var hash = sha256.ComputeHash(stream);
                    return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
                }
            }
        }

        public static string GetRootDir()
        {
            return Directory.GetParent(
                    Directory.GetParent(
                        Directory.GetParent(
                            Directory.GetParent(
                                Directory.GetParent(
                                    System.Reflection.Assembly.GetExecutingAssembly().Location
                                    ).FullName
                                ).FullName
                            ).FullName
                        ).FullName
                    ).FullName;
        }

        public static void SetButtonState(Button button, bool enable)
        {
            button.Invoke((MethodInvoker)delegate
            {
                button.Enabled = enable;
            });
        }
        public static void SetProgressBar(ProgressBar progressBar, int percentage, bool error)
        {
            progressBar.Invoke((MethodInvoker)delegate
            {
                if (error)
                    progressBar.ForeColor = Color.Red;
                else
                    progressBar.ForeColor = Color.Green;

                progressBar.Style = ProgressBarStyle.Continuous;
                progressBar.Value = (int)(percentage * progressBar.Maximum / 100);
            });
        }

        public static IEnumerable<string> EnumerateDirectoryFiles(string rootPath, string patternMatch, SearchOption searchOption)
        {
            var foundFiles = Enumerable.Empty<string>();

            if (searchOption == SearchOption.AllDirectories)
            {
                try
                {
                    IEnumerable<string> subDirs = Directory.EnumerateDirectories(rootPath);
                    foreach (string dir in subDirs)
                    {
                        foundFiles = foundFiles.Concat(EnumerateDirectoryFiles(dir, patternMatch, searchOption));
                    }
                }
                catch (UnauthorizedAccessException) { }
                catch (PathTooLongException) { }
            }

            try
            {
                foundFiles = foundFiles.Concat(Directory.EnumerateFiles(rootPath, patternMatch));
            }
            catch (UnauthorizedAccessException) { }

            return foundFiles;
        }

        public static string ExecutePythonMain()
        {
            var pyAppDir = Path.Combine(Wrapper.GetRootDir(), "PyApp");
            var cmdPath = Environment.ExpandEnvironmentVariables(@"%WinDir%\System32\cmd.exe");
            var scriptsDir = Environment.ExpandEnvironmentVariables(@"%HOMEDRIVE%\Setup\venv\Scripts");
            var activatePath = Path.Combine(scriptsDir, "activate.bat");

            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = cmdPath;
            startInfo.WorkingDirectory = pyAppDir;

            startInfo.Arguments = string.Format("/k " + "\"" +
                " \"\"{0}\"\"" +
                " & cd /d \"\"{1}\"\"" +
                " & main.py & exit(0) " +
                "\"",
                activatePath,
                pyAppDir);

            startInfo.UseShellExecute = false;
            startInfo.RedirectStandardOutput = true;
            startInfo.CreateNoWindow = true;

            string output = string.Empty;

            using (var process = Process.Start(startInfo))
            {
                output = process.StandardOutput.ReadToEnd();
                process.WaitForExit();                
            }

            return output;
        }

        public static string GetProcessCommandLine(UInt32 pid)
        {
            using (ManagementObjectSearcher searcher = new ManagementObjectSearcher("SELECT CommandLine FROM Win32_Process WHERE ProcessId = " + pid))
            {
                using (ManagementObjectCollection objects = searcher.Get())
                {
                    return objects.Cast<ManagementBaseObject>().SingleOrDefault()?["CommandLine"]?.ToString();
                }
            }
        }

        public static bool ScanFiles(FileTypeEnum type, FileFormatEnum srcFormat, string[] inputPaths, out List<int> newMalwareHistoryIds, out string message)
        {
            message = "";
            bool hasError = false;

            var targetPaths = new List<string>();
            var filesDict = new Dictionary<string, string>();
            newMalwareHistoryIds = new List<int>();

            try
            {
                var filteredInputPaths = new List<string>();
                foreach (var inputPath in inputPaths)
                {
                    if (!filteredInputPaths.Any(x => x.Equals(inputPath, StringComparison.OrdinalIgnoreCase)))
                        filteredInputPaths.Add(inputPath);
                }
                inputPaths = filteredInputPaths.ToArray();

                if (type == FileTypeEnum.FILES)
                {
                    // Convert to graph
                    if (srcFormat != FileFormatEnum.GRAPH)
                    {
                        foreach (var inputPath in inputPaths)
                        {
                            var graphPath = Path.Combine(TEMP_DIR, Guid.NewGuid().ToString("D"));

                            try
                            {
                                if (Home.GetInstance().miningController.Convert(inputPath, string.Empty, srcFormat, graphPath, FileFormatEnum.GRAPH, false))
                                {
                                    targetPaths.Add(graphPath);
                                    filesDict[graphPath] = inputPath;
                                }
                            }
                            catch (Exception ex)
                            {
                                if (File.Exists(graphPath))
                                    File.Delete(graphPath);
                            }
                        }
                    }
                    else
                    {
                        targetPaths = inputPaths.ToList();

                        foreach (var path in inputPaths)
                        {
                            filesDict[path] = path;
                        }
                    }
                }
                else
                {
                    targetPaths = inputPaths.ToList();
                }

                // Load settings
                var appSettingsPath = Path.Combine(Home.GetInstance().GetDataLocation(), APP_SETTINGS_FILE_NAME);
                if (!File.Exists(appSettingsPath))
                    throw new Exception("App settings not found");
                AppSettings appSettings = JsonConvert.DeserializeObject<AppSettings>(File.ReadAllText(appSettingsPath));

                if (!File.Exists(appSettings.ConfigPath))
                    throw new Exception("Model config not found");
                ModelConfig modeConfig = JsonConvert.DeserializeObject<ModelConfig>(File.ReadAllText(appSettings.ConfigPath));

                Environment.SetEnvironmentVariable(MODE_ID_ENV_NAME, ((int)ModeEnum.SCAN).ToString());
                Environment.SetEnvironmentVariable(OUTPUT_DIR_ENV_NAME, OUTPUT_DIR);

                Environment.SetEnvironmentVariable(CLASSIFIER_PATH_ENV_NAME, appSettings.ClassifierPath);
                Environment.SetEnvironmentVariable(SCALER_PATH_ENV_NAME, appSettings.DataScalerPath);
                Environment.SetEnvironmentVariable(DECOMPOSITION_PATH_ENV_NAME, appSettings.DataDecompositionPath);
                Environment.SetEnvironmentVariable(EXTRA_PATH_ENV_NAME, appSettings.ExtraDataPath);

                Environment.SetEnvironmentVariable(TARGET_TYPE_ID_ENV_NAME, ((int)type).ToString());
                Environment.SetEnvironmentVariable(TARGET_PATHS_ENV_NAME, string.Join(";", targetPaths));

                Environment.SetEnvironmentVariable(FEATURE_ID_ENV_NAME, modeConfig.feature_id.ToString());
                Environment.SetEnvironmentVariable(SEQUENCE_LEN_ENV_NAME, modeConfig.sequence_len.ToString());

                var output = Wrapper.ExecutePythonMain();
                var predictLine = output.Split('\n').Where(line => line.Contains("predicts:")).FirstOrDefault();

                bool[] predicts = new bool[0];
                if (predictLine != null && predictLine.Length > 0)
                {
                    int pred = 0;
                    predicts = predictLine.Split(' ')
                        .Select(part => part.Trim())
                        .Where(part => part.Length > 0 && int.TryParse(part, out pred))
                        .Select(part => int.Parse(part) > 0)
                        .ToArray();
                }

                var filesScanningControler = Home.GetInstance().filesScanningControler;
                var histories = filesScanningControler.LoadHistory();
                int nextId = 0;
                if (histories.Count > 0)
                    nextId = histories.Max(x => x.Id) + 1;

                for (int iPredict = 0; iPredict < predicts.Length; iPredict++)
                {
                    histories.Add(new FileHistoryRecord(nextId, filesDict[targetPaths[iPredict]], srcFormat, predicts[iPredict]));
                    if (predicts[iPredict])
                        newMalwareHistoryIds.Add(nextId);
                    nextId += 1;
                }
                filesScanningControler.SaveHistory(histories);
                filesScanningControler.BindHitoryToView(histories);

                message = "SCAN RESULT" + Environment.NewLine;
                message += "Total: " + inputPaths.Length.ToString() + Environment.NewLine;
                message += "Valid:" + predicts.Length.ToString() + Environment.NewLine;
                message += "Detected: " + predicts.Count(x => x).ToString() + Environment.NewLine;
            }
            catch (Exception ex)
            {
                MessageBox.Show("Exception: " + ex.Message);
                hasError = true;
            }

            return !hasError;
        }
    }
}
