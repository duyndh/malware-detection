using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using static WindowsFormsApp1.Controls.MiningUserControl;

namespace WindowsFormsApp1.Controllers
{
    class Wrapper
    {
        public static string ConvertToAlphaNumString(string inputStr)
        {
            return Regex.Replace(inputStr, "[^a-zA-Z0-9]+", "_");
        }

        public static string CalculateFileHash(string filePath)
        {
            using (var sha256 = SHA256.Create())
            {
                using (var stream = File.OpenRead(filePath))
                {
                    var hash = sha256.ComputeHash(stream);
                    return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
                }
            }
        }

        public static string GetRootDir()
        {
            return Directory.GetParent(
                    Directory.GetParent(
                        Directory.GetParent(
                            Directory.GetParent(
                                Directory.GetParent(
                                    System.Reflection.Assembly.GetExecutingAssembly().Location
                                    ).FullName
                                ).FullName
                            ).FullName
                        ).FullName
                    ).FullName;
        }

        public static void SetButtonState(Button button, bool enable)
        {
            button.Invoke((MethodInvoker)delegate
            {
                button.Enabled = enable;
            });
        }
        public static void SetProgressBar(ProgressBar progressBar, int percentage)
        {
            progressBar.Invoke((MethodInvoker)delegate
            {
                progressBar.Value = (int)(percentage * progressBar.Maximum / 100);
            });
        }

        public static IEnumerable<string> EnumerateDirectoryFiles(string rootPath, string patternMatch, SearchOption searchOption)
        {
            var foundFiles = Enumerable.Empty<string>();

            if (searchOption == SearchOption.AllDirectories)
            {
                try
                {
                    IEnumerable<string> subDirs = Directory.EnumerateDirectories(rootPath);
                    foreach (string dir in subDirs)
                    {
                        foundFiles = foundFiles.Concat(EnumerateDirectoryFiles(dir, patternMatch, searchOption));
                    }
                }
                catch (UnauthorizedAccessException) { }
                catch (PathTooLongException) { }
            }

            try
            {
                foundFiles = foundFiles.Concat(Directory.EnumerateFiles(rootPath, patternMatch));
            }
            catch (UnauthorizedAccessException) { }

            return foundFiles;
        }

        public static string ExecutePythonMain()
        {
            var pyAppDir = Path.Combine(Wrapper.GetRootDir(), "PyApp");
            var cmdPath = Environment.ExpandEnvironmentVariables(@"%WinDir%\System32\cmd.exe");
            var scriptsDir = Environment.ExpandEnvironmentVariables(@"%HOMEDRIVE%\Setup\venv\Scripts");
            var activatePath = Path.Combine(scriptsDir, "activate.bat");

            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.FileName = cmdPath;
            startInfo.WorkingDirectory = pyAppDir;

            startInfo.Arguments = string.Format("/k " + "\"" +
                " \"\"{0}\"\"" +
                " & cd /d \"\"{1}\"\"" +
                " & main.py & exit(0) " +
                "\"",
                activatePath,
                pyAppDir);

            startInfo.UseShellExecute = false;
            startInfo.RedirectStandardOutput = true;
            startInfo.CreateNoWindow = true;

            string output = string.Empty;

            using (var process = Process.Start(startInfo))
            {
                output = process.StandardOutput.ReadToEnd();
                process.WaitForExit();                
            }

            return output;
        }
    }
}
