// TestApp.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <string>

bool WINAPI DisassemblyFile(LPSTR input_file_path, LPSTR asm_file_path, LPSTR output_file_path);
typedef decltype(&DisassemblyFile) FN_DisassemblyFile;

bool WINAPI BuildInstructionsGraph(LPSTR input_file_path, LPSTR output_file_path);
typedef decltype(&BuildInstructionsGraph) FN_BuildInstructionsGraph;

bool WINAPI BuildGraphFromFile(LPSTR input_file_path, LPSTR asm_file_path, LPSTR output_file_path);
typedef decltype(&BuildGraphFromFile) FN_BuildGraphFromFile;


int main()
{
	if (0)
	{
		HMODULE hLib = LoadLibraryA("NativeLib.dll");
		FN_DisassemblyFile fnDisassemblyFile = (FN_DisassemblyFile)GetProcAddress(hLib, "DisassemblyFile");
		FN_BuildInstructionsGraph fnBuildInstructionsGraph = (FN_BuildInstructionsGraph)GetProcAddress(hLib, "BuildInstructionsGraph");
		FN_BuildGraphFromFile fnBuildGraphFromFile = (FN_BuildGraphFromFile)GetProcAddress(hLib, "BuildGraphFromFile");

		//"c:\\temp\\asm\\01kcPWA9K2BOxQeS5Rju.bytes";
		std::string bytes_file_path = "f:\\02mlBLHZTDFXGa7Nt6cr.bytes";
		//"c:\\temp\\asm\\01kcPWA9K2BOxQeS5Rju.asm";
		std::string asm_file_path = "f:\\02mlBLHZTDFXGa7Nt6cr.asm";

		//std::string standard_file_path = "c:\\temp\\asmout\\c_temp_asm_Fo3l7eAEM4XDmKyIV9tj_bytes.scsv";
		std::string graph_file_path = "c:\\temp\\asmout\\graph.csv";

		bool result = false;

		//result = fnDisassemblyFile((LPSTR)bytes_file_path.c_str(), (LPSTR)asm_file_path.c_str(), (LPSTR)standard_file_path.c_str());
		//result = fnBuildInstructionsGraph((LPSTR)standard_file_path.c_str(), (LPSTR)graph_file_path.c_str());

		result = fnBuildGraphFromFile((LPSTR)bytes_file_path.c_str(), (LPSTR)asm_file_path.c_str(), (LPSTR)graph_file_path.c_str());
	}

	if (1)
	{
//#include <subauth.h>
//#include <winternl.h>

        HANDLE process_handle = NULL;
        do
        {
            typedef NTSTATUS(NTAPI* _NtQueryInformationProcess)(
                HANDLE ProcessHandle,
                DWORD ProcessInformationClass,
                PVOID ProcessInformation,
                DWORD ProcessInformationLength,
                PDWORD ReturnLength
                );
            HMODULE ntdll_handle = GetModuleHandleA("ntdll.dll");
            _NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(ntdll_handle, "NtQueryInformationProcess");

            typedef struct _PROCESS_BASIC_INFORMATION
            {
                LONG ExitStatus;
                PVOID PebBaseAddress;
                ULONG_PTR AffinityMask;
                LONG BasePriority;
                ULONG_PTR UniqueProcessId;
                ULONG_PTR ParentProcessId;
            } PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

            typedef struct _UNICODE_STRING {
                USHORT Length;
                USHORT MaximumLength;
                PWSTR  Buffer;
            } UNICODE_STRING, * PUNICODE_STRING;
        	
            typedef struct _RTL_USER_PROCESS_PARAMETERS {
                BYTE           Reserved1[16];
                PVOID          Reserved2[10];
                UNICODE_STRING ImagePathName;
                UNICODE_STRING CommandLine;
            } RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

            typedef struct _PEB_LDR_DATA {
                BYTE       Reserved1[8];
                PVOID      Reserved2[3];
                LIST_ENTRY InMemoryOrderModuleList;
            } PEB_LDR_DATA, *PPEB_LDR_DATA;
        	
            typedef struct _PEB {
                BYTE                          Reserved1[2];
                BYTE                          BeingDebugged;
                BYTE                          Reserved2[1];
                PVOID                         Reserved3[2];
                PPEB_LDR_DATA                 Ldr;
                PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
                PVOID                         Reserved4[3];
                PVOID                         AtlThunkSListPtr;
                PVOID                         Reserved5;
                ULONG                         Reserved6;
                PVOID                         Reserved7;
                ULONG                         Reserved8;
                ULONG                         AtlThunkSListPtr32;
                PVOID                         Reserved9[45];
                BYTE                          Reserved10[96];
                LPVOID                        PostProcessInitRoutine;
                BYTE                          Reserved11[128];
                PVOID                         Reserved12[1];
                ULONG                         SessionId;
            } PEB, *PPEB;
        	
			process_handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, 28800);
            if (!process_handle)
                break;

        	PROCESS_BASIC_INFORMATION pbi = {0};
            NtQueryInformationProcess(process_handle, 0, &pbi, sizeof(pbi), NULL);
            PPEB peb_ptr = (PPEB)pbi.PebBaseAddress;

            LPBYTE rtlUserProcParamsAddress;
            if (!ReadProcessMemory(process_handle, peb_ptr->ProcessParameters, &rtlUserProcParamsAddress, sizeof(PVOID), NULL))
                break;

            break;

            ///* read the CommandLine UNICODE_STRING structure */
            //if (!ReadProcessMemory(processHandle, (PCHAR)rtlUserProcParamsAddress + 0x40,
            //    &commandLine, sizeof(commandLine), NULL))
            //{
            //    printf("Could not read CommandLine!\n");
            //    return GetLastError();
            //}

            ///* allocate memory to hold the command line */
            //commandLineContents = (WCHAR*)malloc(commandLine.Length);

            ///* read the command line */
            //if (!ReadProcessMemory(processHandle, commandLine.Buffer,
            //    commandLineContents, commandLine.Length, NULL))
            //{
            //    printf("Could not read the command line string!\n");
            //    return GetLastError();
            //}
        	
            //printf("%.*S\n", commandLine.Length / 2, commandLineContents);
            /*CloseHandle(processHandle);
            free(commandLineContents);*/
        } while (false);

		if (process_handle)
			CloseHandle(process_handle);
	}
	
    return 0;
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
