
def get_code_section(pe):

    if pe.OPTIONAL_HEADER.SizeOfCode == 0:
        return None

    addresses = []
    for section in pe.sections:
        addresses.append(section.VirtualAddress)

    base_of_code = pe.OPTIONAL_HEADER.BaseOfCode
    if base_of_code in addresses:
        return pe.sections[addresses.index(base_of_code)]
    else:
        addresses.append(base_of_code)
        addresses.sort()
        if addresses.index(base_of_code) != 0:
            return pe.sections[addresses.index(base_of_code) - 1]
        else:
            return None
    pass

def disassemble(pe_file_path):

    # Parse exe file
    pe = pefile.PE(pe_file_path)

    # Get code section
    code_section = get_code_section(pe)
    if code_section == None:
        return None

    # Create capstone engine
    mode = 0
    if pe.FILE_HEADER.Machine == 0x8664:
        mode = CS_MODE_64
    elif pe.FILE_HEADER.Machine == 0x14c:
        mode = CS_MODE_32
    else:
        return None
    engine = Cs(CS_ARCH_X86, mode)

    instructions = []
    engine.detail = True
    last_address = 0
    last_size = 0

    # Get instructions
    begin = code_section.PointerToRawData
    end = begin + code_section.SizeOfRawData
    while True:
        data = pe.get_memory_mapped_image()[begin:end]
        for inst in engine.disasm(data, begin):
            instructions.append({"opcode": inst.mnemonic})
            last_address = int(inst.address)
            last_size = inst.size

        begin = max(int(last_address), begin) + last_size + 1
        if begin >= end:
            break

    return instructions

if __name__ == '__main__':

    # Disassemble
    pe_file_path = os.path.expandvars("%SystemDrive%\\Temp\\appcmd.exe.mui")

    try:

        # Disassemble
        instructions = disassemble(pe_file_path)
        if instructions == None:
            raise Exception()

        for ins in instructions:
            print(ins["opcode"])

        pass
    except:
        pass

    pass