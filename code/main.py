import os
import csv
import pefile
import hashlib
from capstone import *
from capstone.x86 import *

def load_dataset(dataset_dir, csv_file_name, machines_filter, file_count_limit, file_size_limit):

    print("================")
    print(load_dataset.__name__)

    origin_files = []

    with open(os.path.join(dataset_dir, csv_file_name), newline='') as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            origin_files.append(row)

    percentage = 0
    print(0, "%")

    filtered_files = []
    file_count_limit = min(len(origin_files), file_count_limit)

    for origin_file in origin_files:

        # Exceed limit of of file count
        if len(filtered_files) >= file_count_limit:
            break

        if (int)(len(filtered_files) * 100 / file_count_limit) > percentage:
            percentage = (int)(len(filtered_files) * 100 / file_count_limit)
            print(percentage, "%")

        # Build path
        file_path = os.path.join(dataset_dir, origin_file["name"])

        # Exceed limit of file size
        if os.stat(file_path).st_size > file_size_limit:
            continue

        # Not expected machine
        if int(row["machine"]) not in machines_filter:
            continue

        # Calculate checksum
        checksum = hashlib.md5(open(file_path, 'rb').read()).hexdigest()
        if origin_file["md5"] != checksum:
            continue

        # Add to result
        filtered_files.append({"path": file_path, "machine": origin_file["machine"]})

        pass

    print(100, "%")
    return filtered_files



def get_main_code_section(sections, base_of_code):
    addresses = []
    # get addresses of all sections
    for section in sections:
        addresses.append(section.VirtualAddress)

    # if the address of section corresponds to the first instruction then
    # this section should be the main code section
    if base_of_code in addresses:
        return sections[addresses.index(base_of_code)]
    # otherwise, sort addresses and look for the interval to which the base of code
    # belongs
    else:
        addresses.append(base_of_code)
        addresses.sort()
        if addresses.index(base_of_code) != 0:
            return sections[addresses.index(base_of_code) - 1]
        else:
            # this means we failed to locate it
            return None

def fine_disassemble(exe):
    #get main code section
    main_code = get_main_code_section(exe.sections, exe.OPTIONAL_HEADER.BaseOfCode)
    #define architecutre of the machine
    md = Cs(CS_ARCH_X86, CS_MODE_32)
    md.detail = True
    last_address = 0
    last_size = 0
    #Beginning of code section
    begin = main_code.PointerToRawData
    #the end of the first continuous bloc of code
    end = begin+main_code.SizeOfRawData
    while True:
        #parse code section and disassemble it
        data = exe.get_memory_mapped_image()[begin:end]
        for i in md.disasm(data, begin):
            print(i)
            last_address = int(i.address)
            last_size = i.size
        #sometimes you need to skip some bytes
        begin = max(int(last_address),begin)+last_size+1
        if begin >= end:
            print("out")
            break

if __name__ == '__main__':

    # Benign dataset
    #origin_benign_files = load_dataset(os.path.expanduser("~//workspace//datasets//dataset_benign"), "_benign.csv", [332], 200, 1024 * 1024)
    # Malware dataset
    #origin_malware_files = load_dataset(os.path.expanduser("~//workspace//datasets//Virus.Win"), "_malware.csv", [332], 200, 1024 * 1024)


    # Disassembly
    exe_file_path = os.path.expanduser("~//workspace//datasets//dataset_benign//appcmd.exe.mui")

    try:
        # parse exe file
        exe = pefile.PE(exe_file_path)

        try:
            # call the function we created earlier
            fine_disassemble(exe)
        except:
            print('something is wrong with this exe file')
    except:
        print('pefile cannot parse this file')

    pass