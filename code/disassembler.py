import pefile
from capstone import *
import codecs
import re

class DisAssembler:

    @staticmethod
    def get_code_section(pe):

        if pe.OPTIONAL_HEADER.SizeOfCode == 0:
            return None

        addresses = []
        for section in pe.sections:
            addresses.append(section.VirtualAddress)

        base_of_code = pe.OPTIONAL_HEADER.BaseOfCode
        if base_of_code in addresses:
            return pe.sections[addresses.index(base_of_code)]
        else:
            addresses.append(base_of_code)
            addresses.sort()
            if addresses.index(base_of_code) != 0:
                return pe.sections[addresses.index(base_of_code) - 1]
            else:
                return None
        pass


    @staticmethod
    def extract_opcode_from_asm(asm_file_path):

        lines = []
        with codecs.open(asm_file_path, mode="r", encoding="utf-8", errors='replace') as f:
            lines = f.readlines()

        if len(lines) == 0:
            return None

        instructions = []
        for line in lines:
            try:
                if not line.startswith(".text:"):
                    continue

                parts = re.split(" |\t", line)
                if len(parts) <= 1 or len(parts[1]) != 2:
                    continue

                opcode = int(parts[1], 16)
                instructions.append(opcode)

            except:
                pass

        return instructions

    @staticmethod
    def extract_opcodes_from_pe(pe_file_path):

        # Parse exe file
        pe = pefile.PE(pe_file_path)

        # Get code section
        code_section = DisAssembler.get_code_section(pe)
        if code_section == None:
            return None

        # Create capstone engine
        mode = 0
        if pe.FILE_HEADER.Machine == 0x8664:
            mode = CS_MODE_64
        elif pe.FILE_HEADER.Machine == 0x14c:
            mode = CS_MODE_32
        else:
            return None
        engine = Cs(CS_ARCH_X86, mode)

        instructions = []
        engine.detail = True
        last_address = 0
        last_size = 0

        # Get instructions
        begin = code_section.PointerToRawData
        end = begin + code_section.SizeOfRawData
        while True:
            data = pe.get_memory_mapped_image()[begin:end]
            for inst in engine.disasm(data, begin):
                opcode = int(inst.opcode[0])
                instructions.append(opcode)

                last_address = int(inst.address)
                last_size = inst.size

            begin = max(int(last_address), begin) + last_size + 1
            if begin >= end:
                break

        return instructions