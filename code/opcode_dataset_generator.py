from disassembler import *

class OpcodeDatasetGenerator:

    @staticmethod
    def generate(file_paths, output_csv_file_path):
        print("Generating opcode dataset...")

        percentage = 0
        print(0, "%")

        with open(output_csv_file_path, 'w', newline='') as csv_file:
            writer = csv.DictWriter(csv_file, fieldnames=["path", "opcodes"])
            writer.writeheader()
            for path_index, path in enumerate(file_paths):

                if int(path_index * 100 / len(file_paths)) > percentage:
                    percentage = int(path_index * 100 / len(file_paths))
                    print(percentage, "%")

                opcodes = DisAssembler.extract_opcodes(path)

                if len(opcodes) == 0:
                    continue

                opcode_hex = "".join("{:02x}".format(x) for x in opcodes)
                b64 = base64.b64encode(bytes.fromhex(opcode_hex)).decode()
                writer.writerow({"path": path, "opcodes": b64})

        print(100, "%")
        pass

    @staticmethod
    def load(csv_file_path, limit_file_count):

        print("Loading opcode dataset...")

        percentage = 0
        print(0, "%")

        opcode_dataset = []

        with open(csv_file_path, newline='') as csv_file:

            reader = csv.DictReader(csv_file)
            data = list(reader)
            for row_index, row in enumerate(data):

                if int(row_index * 100 / len(data)) > percentage:
                    percentage = int(row_index * 100 / len(data))
                    print(percentage, "%")

                if len(opcode_dataset) >= limit_file_count:
                    break

                path = row["path"]
                b64 = row["opcodes"]

                decoded_hex = base64.b64decode(b64.encode()).hex()
                opcodes = [int(x) for x in bytes.fromhex(decoded_hex)]

                if len(opcodes) > 0:
                    opcode_dataset.append(opcodes)

        print(100, "%")

        return opcode_dataset