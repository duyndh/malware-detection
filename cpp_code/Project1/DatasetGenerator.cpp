#include "pch.h"
#include "DatasetGenerator.h"
#include "Wrapper.h"
#include "Disassembler.h"
#include "AsmParser.h"

void DatasetGenerator::Generate()
{
	/*std::string strDir = "F:\\Dataset";
	std::cout << "Directory: " << strDir << std::endl;
	auto liAsmFilePaths = Wrapper::NativeRecursiveEnumFiles(strDir, { CSV_EXT });
	std::cout << "Total: " << liAsmFilePaths.size() << std::endl;

	size_t iFile = 0;
	for (auto& path : liAsmFilePaths)
	{
		iFile++;
		std::cout << iFile << "/" << liAsmFilePaths.size() << " " << path << std::endl;

		std::list<std::string> liFileLines;
		{
			std::ifstream asmFile(path);
			liFileLines.push_back("Address,Opcode,Operands,Bytes");
			std::string strLine;
			while (std::getline(asmFile, strLine))
			{
				auto liParts = Wrapper::Split(strLine, ",");
				strLine.clear();
				for (auto& strPart : liParts)
				{
					while (strPart.length() > 0 && strPart.front() == ' ')
					{
						strPart.erase(0, 1);
					}

					if (!strLine.length())
					{
						strLine = strPart;
					}
					else
					{
						strLine += ",";
						strLine += strPart;
					}
				}

				liFileLines.push_back(strLine);
			}

			asmFile.close();
		}

		{
			std::ofstream outFile(path);

			for (auto& strLine : liFileLines)
				outFile << strLine << std::endl;

			outFile.close();
		}
	}

	return 0;*/

	// Parse log file
	std::set<std::string> setFilePaths;
	if (std::filesystem::exists(LOG_FILE_PATH))
	{
		std::ifstream logFile(LOG_FILE_PATH);

		bool bOk = true;
		std::string strLogLine;
		while (std::getline(logFile, strLogLine))
		{
			size_t iPos = strLogLine.find(' ', 0);
			if (iPos == strLogLine.npos)
			{
				bOk = false;
				break;
			}
			iPos = strLogLine.find(' ', iPos + 1);
			if (iPos == strLogLine.npos)
			{
				bOk = false;
				break;
			}
			std::string strFilePath = strLogLine.substr(iPos + 1);
			std::transform(strFilePath.begin(), strFilePath.end(), strFilePath.begin(), [](unsigned char c) { return std::tolower(c); });
			setFilePaths.insert(strFilePath);
		}
		logFile.close();

		if (!bOk)
		{
			std::cout << "Error to parse log file" << std::endl;
			return;
		}
	}

	std::set<DWORD> setChecksum;

	std::vector<std::string> vecScanDirs = SCAN_DIRS;
	std::set<std::string> setExtensions = PE_EXTS;

	for (const auto& strDir : vecScanDirs)
	{
		std::cout << "Directory: " << strDir << std::endl;
		auto liPeFilePaths = Wrapper::NativeRecursiveEnumFiles(strDir, PE_EXTS);
		std::cout << "Total: " << liPeFilePaths.size() << std::endl;

		size_t iFile = 0;
		for (auto& strPeFilePath : liPeFilePaths)
		{
			iFile++;
			std::cout << iFile << "/" << liPeFilePaths.size();
			std::transform(strPeFilePath.begin(), strPeFilePath.end(), strPeFilePath.begin(), [](unsigned char c) { return std::tolower(c); });

			std::cout << ' ' << strPeFilePath;

			// Exist
			auto dwChecksum = Wrapper::GetFileCheckSum(strPeFilePath);
			bool bExist = setChecksum.find(dwChecksum) != setChecksum.end();
			if (bExist)
			{
				std::cout << " exist" << std::endl;
				continue;
			}
			else
			{
				setChecksum.insert(dwChecksum);

				if (setFilePaths.find(strPeFilePath) != setFilePaths.end())
				{
					std::cout << " old" << std::endl;
					continue;
				}
				else
					std::cout << std::endl;
			}

			Disassembler disasm(strPeFilePath);
			std::string strTmpAsmPath = disasm.GenerateAsmFile("");

			AsmParser parser(strTmpAsmPath, false);
			if (parser.ParseNative())
			{
				parser.ExportToCsvFile(OUTPUT_DIR, strPeFilePath);
			}

			// Log
			{
				auto machineType = parser.GetMachineType();
				std::string strMachineName = "";
				if (machineType == MachineType_X64)
					strMachineName = "X64";
				else if (machineType == MachineType_X86)
					strMachineName = "X86";
				else
					strMachineName = "Unknown";

				Wrapper::Log(
					strMachineName
					+ " " + Wrapper::GetHexString(parser.GetImageBase())
					+ " " + strPeFilePath);
			}
		}
	}
}
