#include "pch.h"
#include "GraphBuilder.h"
#include "Wrapper.h"

GraphBuilder::GraphBuilder(const std::string& strFilePath)
{
	m_strFilePath = strFilePath;
}

void GraphBuilder::Build()
{
	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	// Skip header
	std::getline(inFile, strLine);

	// Init unknown node
	{
		InstructionNode unknownNode;		
		m_mapInstruction.insert({ MAXDWORD64, unknownNode });
	}
	
	// Content
	while (std::getline(inFile, strLine))
	{
		// To lower
		std::transform(strLine.begin(), strLine.end(), strLine.begin(), [](unsigned char c) { return std::tolower(c); });

		// Split csv line
		auto liParts = Wrapper::Split(strLine, ",");
		if (liParts.size() != 4)
			continue;

		auto itPart = liParts.begin();
		if (!Wrapper::CheckHexString(*itPart, false))
			continue;
		
		// Instruction address
		DWORD64 qwAddress = std::stoull(*itPart, NULL, 16);
		itPart = std::next(itPart);

		InstructionNode node;

		// Opcode str
		node.strOpCode = *itPart;
		itPart = std::next(itPart);

		// Operands
		node.liRawOperands = Wrapper::Split(*itPart, " ");
		itPart = std::next(itPart);

		// Opcode byte
		std::vector<BYTE> vecBytes = Wrapper::DecodeBase64(*itPart);
		if (vecBytes.empty())
			continue;
		node.bOpCode = vecBytes.front();
		itPart = std::next(itPart);

		// Insert
		m_mapInstruction.insert({ qwAddress, node });
	}
	inFile.close();
	
	std::list<DWORD64> liRetAddress;

	// Link
	for (auto it = m_mapInstruction.begin(); it != m_mapInstruction.end(); it++)
	{
		DWORD64 qwCurrentAddress = it->first;
		InstructionNode* pNode = &it->second;

		DWORD64 qwJumpAddress = MAXDWORD64;
		JumpAddressType jumpAddressType = JumpAddressType_Unknown;

		if (pNode->strOpCode.empty())
			continue;

		// Iterate each operand
		for (auto& strOperand : pNode->liRawOperands)
		{
			// Find register
			auto liSubOperandParts = Wrapper::Split(strOperand, "", false, true);
			for (auto& strSubOperand : liSubOperandParts)
			{
				if (REGISTERS_MAP.find(strSubOperand) != REGISTERS_MAP.end())
					pNode->liRegisterOperands.push_back(REGISTERS_MAP.at(strSubOperand));
			}

			if (pNode->strOpCode.front() != 'j' && pNode->strOpCode.find("call") == pNode->strOpCode.npos)
				continue;
			
			// Skip finding imm if found jump address
			if (jumpAddressType != JumpAddressType_Unknown)
				continue;

			// Find imm in case no pointer
			if (strOperand.find('[') != strOperand.npos || strOperand.find(']') != strOperand.npos)
				continue;

			// Remove dummy
			if (strOperand.back() == 'h')
				strOperand.erase(strOperand.length() - 1);
			if (liSubOperandParts.size() == 2)
				strOperand = liSubOperandParts.back();

			// Is hex
			if (!Wrapper::CheckHexString(strOperand, false))
				continue;

			// Convert to number
			DWORD64 qwImm = std::stoll(strOperand, NULL, 16);

			// Out of range
			if (qwImm < m_mapInstruction.begin()->first || qwImm > std::prev(std::prev(m_mapInstruction.end()))->first)
				continue;

			// Found
			if (m_mapInstruction.find(qwImm) != m_mapInstruction.end())
			{
				qwJumpAddress = qwImm;
				jumpAddressType = JumpAddressType_Direct;
			}
			// Not found
			else
			{
				jumpAddressType = JumpAddressType_Near;
			}
		}
		
		// Next instruction address
		DWORD64 qwNextAddress = 0;
		if (std::next(it) != std::prev(m_mapInstruction.end()))
			qwNextAddress = std::next(it)->first;

		// Jump
		if (pNode->strOpCode.front() == 'j')
		{
			// Add jump address
			pNode->liNextAddress.push_back({ qwJumpAddress, jumpAddressType });
			m_mapInstruction[qwJumpAddress].liPrevAddress.push_back(qwCurrentAddress);

			// Add next address
			if (pNode->strOpCode != "jmp")
			{
				if (qwNextAddress && qwNextAddress != qwJumpAddress)
				{
					pNode->liNextAddress.push_back({ qwNextAddress, JumpAddressType_Direct });
					m_mapInstruction[qwNextAddress].liPrevAddress.push_back(qwCurrentAddress);
				}
			}
		}
		// Call
		else if (pNode->strOpCode.find("call") != pNode->strOpCode.npos)
		{
			// Add jump address
			pNode->liNextAddress.push_back({ qwJumpAddress, jumpAddressType });
			m_mapInstruction[qwJumpAddress].liPrevAddress.push_back(qwCurrentAddress);
		}
		// Ret
		else if (pNode->strOpCode.find("ret") != pNode->strOpCode.npos)
		{
			// Later
			liRetAddress.push_back(qwCurrentAddress);
		}
		// Linear
		else
		{
			if (qwNextAddress)
			{
				pNode->liNextAddress.push_back({ qwNextAddress, JumpAddressType_Direct });
				m_mapInstruction[qwNextAddress].liPrevAddress.push_back(qwCurrentAddress);
			}
		}
	}

	// Link ret
	std::set<DWORD64> setVisitedAddresses;
	std::queue<DWORD64> quBranchAddresses;
	
	for (auto& qwRetAddress : liRetAddress)
	{
		DWORD64 qwCurrentAddress = qwRetAddress;
	
		
		InstructionNode* pCurrentNode = &m_mapInstruction[qwCurrentAddress];
		while (pCurrentNode->strOpCode.find("call") == pCurrentNode->strOpCode.npos)
		{

			//for ()
			//if (pCurrentNode->liPrevAddress.size())
			//{
			//	for 	
			//}
		}
	}
}
