#include "pch.h"
#include "GraphBuilder.h"
#include "Wrapper.h"

void GraphBuilder::BuildNodes(std::string& strLine)
{
	// To lower
	std::transform(strLine.begin(), strLine.end(), strLine.begin(), [](unsigned char c) { return std::tolower(c); });

	// Split csv line
	auto liParts = Wrapper::Split(strLine, ",");
	if (liParts.size() < 3)
		return;

	// Bug: missing operands
	if (liParts.size() == 3)
		liParts.insert(std::next(std::next(liParts.begin())), "");
	
	auto itPart = liParts.begin();
	if (!Wrapper::CheckHexString(*itPart, false))
		return;

	// Instruction address
	DWORD64 qwAddress = std::stoull(*itPart, NULL, 16);
	itPart = std::next(itPart);

	InstructionNode node;

	// Opcode str
	node.strOpCode = *itPart;
	itPart = std::next(itPart);

	// Operands
	node.liRawOperands = Wrapper::Split(*itPart, " ");
	itPart = std::next(itPart);

	// Opcode byte
	std::vector<BYTE> vecBytes = Wrapper::DecodeBase64(*itPart);
	if (vecBytes.empty())
		return;
	node.bOpCode = vecBytes.front();
	itPart = std::next(itPart);

	//
	node.qwDirectPrevAddress = MAXDWORD64;
	node.bHasDirectPrevAddress = false;

	// Insert
	m_mapInstruction.insert({ qwAddress, node });
}

std::set<DWORD64> GraphBuilder::LinkJumps()
{
	std::set<DWORD64> setRetAddress;
	
	// Link
	for (auto it = m_mapInstruction.begin(); it != m_mapInstruction.end(); it++)
	{
		DWORD64 qwCurrentAddress = it->first;
		InstructionNode* pNode = &it->second;

		DWORD64 qwJumpAddress = MAXDWORD64;
		//JumpAddressType jumpAddressType = JumpAddressType_Unknown;
		bool bUnknownJump = true;

		if (pNode->strOpCode.empty())
			continue;

		// Iterate each operand
		for (auto& strOperand : pNode->liRawOperands)
		{
			// Find register
			auto liSubOperandParts = Wrapper::Split(strOperand, "", false, true);
			for (auto& strSubOperand : liSubOperandParts)
			{
				if (REGISTERS_MAP.find(strSubOperand) != REGISTERS_MAP.end())
					pNode->liRegisterOperands.push_back(REGISTERS_MAP.at(strSubOperand));
			}

			if (pNode->strOpCode.front() != 'j' && pNode->strOpCode.find("call") == pNode->strOpCode.npos)
				continue;

			// Skip finding imm if found jump address
			if (!bUnknownJump)
				continue;

			// Find imm in case no pointer
			if (strOperand.find('[') != strOperand.npos || strOperand.find(']') != strOperand.npos)
				continue;

			// Remove dummy
			if (strOperand.back() == 'h')
				strOperand.erase(strOperand.length() - 1);
			if (liSubOperandParts.size() == 2)
				strOperand = liSubOperandParts.back();

			// Is hex
			if (!Wrapper::CheckHexString(strOperand, false))
				continue;

			// Convert to number
			DWORD64 qwImm = std::stoll(strOperand, NULL, 16);

			// Out of range
			if (qwImm < m_mapInstruction.begin()->first || qwImm > std::prev(std::prev(m_mapInstruction.end()))->first)
				continue;

			// Found
			if (m_mapInstruction.find(qwImm) != m_mapInstruction.end())
			{
				qwJumpAddress = qwImm;
				bUnknownJump = false;
			}
			// Not found
			else
			{
				bUnknownJump = false;
			}
		}

		// Next instruction address
		DWORD64 qwNextAddress = 0;
		if (std::next(it) != std::prev(m_mapInstruction.end()))
			qwNextAddress = std::next(it)->first;

		// Jump
		if (pNode->strOpCode.front() == 'j')
		{
			// Add jump address
			pNode->setNextAddress.insert(qwJumpAddress);
			m_mapInstruction[qwJumpAddress].setPrevAddress.insert(qwCurrentAddress);

			// Add next address
			if (pNode->strOpCode != "jmp")
			{
				if (qwNextAddress && qwNextAddress != qwJumpAddress)
				{
					pNode->setNextAddress.insert(qwNextAddress);
					m_mapInstruction[qwNextAddress].setPrevAddress.insert(qwCurrentAddress);
				}
			}
		}
		// Call
		else if (pNode->strOpCode.find("call") != pNode->strOpCode.npos)
		{
			// Add jump address
			pNode->setNextAddress.insert( qwJumpAddress );
			m_mapInstruction[qwJumpAddress].setPrevAddress.insert(qwCurrentAddress);
		}
		// Ret
		else if (pNode->strOpCode.find("ret") != pNode->strOpCode.npos)
		{
			// Later
			setRetAddress.insert(qwCurrentAddress);
		}
		// Linear
		else
		{
			if (qwNextAddress)
			{
				pNode->setNextAddress.insert(qwNextAddress);
				m_mapInstruction[qwNextAddress].setPrevAddress.insert(qwCurrentAddress);
			}
		}
	}

	return setRetAddress;
}

void GraphBuilder::SetDirectPrevForTraceStack(std::stack<DWORD64>& stkTrace, DWORD64 qwAddress)
{
	if (!stkTrace.empty())
	{
		stkTrace.pop();

		while (!stkTrace.empty())
		{
			m_mapInstruction[stkTrace.top()].qwDirectPrevAddress = qwAddress;
			m_mapInstruction[stkTrace.top()].bHasDirectPrevAddress = true;
			stkTrace.pop();
		}
	}
}

void GraphBuilder::TraceCall(DWORD64 qwRetAddress, DWORD64 qwAddress, std::stack<DWORD64>& stkTrace, std::set<DWORD64>& setTraveledAddress, bool bTracing)
{	
	InstructionNode* pCurrentNode = &m_mapInstruction[qwAddress];

	stkTrace.push(qwAddress);	
	//std::cout << qwAddress;
	
	if (setTraveledAddress.find(qwAddress) != setTraveledAddress.end())
	{
		//std::cout << ' ' << "Traveled" << std::endl;
		
		if (bTracing)
			SetDirectPrevForTraceStack(stkTrace, qwAddress);
	}
	else
	{
		setTraveledAddress.insert(qwAddress);

		if (pCurrentNode->bHasDirectPrevAddress)
		{
			//std::cout << ' ' << "Direct" << std::endl;
			
			TraceCall(qwRetAddress, pCurrentNode->qwDirectPrevAddress, stkTrace, setTraveledAddress, false);
		}
		else
		{
			// Meet call instruction
			if (pCurrentNode->strOpCode.find("call") != pCurrentNode->strOpCode.npos)
			{
				//std::cout << ' ' << "Call" << std::endl;
				
				if (bTracing)
					SetDirectPrevForTraceStack(stkTrace, qwAddress);

				auto itCallNext = std::next(m_mapInstruction.find(qwAddress));
				if (itCallNext != m_mapInstruction.end())
				{
					// Link next of ret is call
					DWORD64 qwNextCallAddress = itCallNext->first;
					m_mapInstruction[qwRetAddress].setNextAddress.insert(qwAddress);
					m_mapInstruction[qwAddress].setPrevAddress.insert(qwRetAddress);
				}
			}
			// No more prev
			else if (!pCurrentNode->setPrevAddress.size())
			{
				//std::cout << ' ' << "No more" << std::endl;
				
				if (bTracing)
					SetDirectPrevForTraceStack(stkTrace, qwAddress);
			}
			// Linear
			else if (pCurrentNode->setPrevAddress.size() == 1)
			{
				//std::cout << ' ' << "Linear" << std::endl;
				
				// Trace prev
				TraceCall(qwRetAddress, *pCurrentNode->setPrevAddress.begin(), stkTrace, setTraveledAddress, bTracing);
			}
			// Multiple prev nodes
			else
			{
				//std::cout << ' ' << "Multiple" << std::endl;
				
				if (bTracing)
					SetDirectPrevForTraceStack(stkTrace, qwAddress);
				
				// Trace each prev node
				for (DWORD64 qwPrevAddress : pCurrentNode->setPrevAddress)
				{
					// Trace prev
					TraceCall(qwRetAddress, qwPrevAddress, stkTrace, setTraveledAddress, bTracing);
				}
			}
		}
	}

	if (!stkTrace.empty() && stkTrace.top() == qwAddress)
		stkTrace.pop();
}

void GraphBuilder::LinkRets(const std::set<DWORD64>& setRetAddress)
{
	// Link ret
	for (auto& qwRetAddress : setRetAddress)
	{
		std::stack<DWORD64> stkTrace;
		std::set<DWORD64> setTraveledAddress;
		TraceCall(qwRetAddress, qwRetAddress, stkTrace, setTraveledAddress, true);
	}
}

GraphBuilder::GraphBuilder(const std::string& strFilePath)
{
	m_strFilePath = strFilePath;
}

void GraphBuilder::Build()
{
	// Init unknown node
	InstructionNode unknownNode;
	m_mapInstruction.insert({ MAXDWORD64, unknownNode });

	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	// Skip header
	std::getline(inFile, strLine);

	// Content
	while (std::getline(inFile, strLine))
		BuildNodes(strLine);

	inFile.close();

	// Link jumps
	std::set<DWORD64> setRetAddress;
	setRetAddress = LinkJumps();

	// Link rets
	LinkRets(setRetAddress);
	
	return;
}

void GraphBuilder::PrintGraph()
{
	for (auto it = m_mapInstruction.begin(); it != m_mapInstruction.end(); it++)
	{
		auto pNode = &it->second;
		std::cout << it->first << ' ' << pNode->strOpCode << std::endl;

		std::cout << "Next: ";
		for (auto qwAddress : pNode->setNextAddress)
			std::cout << qwAddress << ' ';
		std::cout << std::endl;

		std::cout << "Prev: ";
		for (auto qwAddress : pNode->setPrevAddress)
			std::cout << qwAddress << ' ';
		std::cout << std::endl;

		std::cout << "Direct: " << pNode->qwDirectPrevAddress;
		std::cout << std::endl;

		std::cout << std::endl;
	}

	return;
}
