#include "pch.h"
#include "GraphBuilder.h"
#include "Wrapper.h"

void GraphBuilder::BuildNodes(std::string& strLine)
{
	// To lower
	std::transform(strLine.begin(), strLine.end(), strLine.begin(), [](unsigned char c) { return std::tolower(c); });

	// Split csv line
	auto liParts = Wrapper::Split(strLine, ",");
	if (liParts.size() < 3)
		return;

	// Bug: missing operands
	if (liParts.size() == 3)
		liParts.insert(std::next(std::next(liParts.begin())), "");
	
	auto itPart = liParts.begin();
	if (!Wrapper::CheckHexString(*itPart, false))
		return;

	// Instruction address
	DWORD64 qwAddress = std::stoull(*itPart, NULL, 16);
	itPart = std::next(itPart);

	InstructionNode node(qwAddress);

	// Opcode str
	node.strOpCode = *itPart;
	itPart = std::next(itPart);

	// Check pseudo ins
	bool bPseudoInstruction = m_SET_PSEUDO_OPCODES.find(node.strOpCode) != m_SET_PSEUDO_OPCODES.end();
	
	// Operands
	if (!bPseudoInstruction)
		node.liRawOperands = Wrapper::Split(*itPart, " ");
	itPart = std::next(itPart);

	// Opcode byte
	if (!bPseudoInstruction)
	{
		std::vector<BYTE> vecBytes = Wrapper::DecodeBase64(*itPart);
		if (vecBytes.empty())
			return;
		node.bOpCode = vecBytes.front();
	}
	itPart = std::next(itPart);

	// Insert
	m_mapAddressToIndex[qwAddress] = m_vecInstructions.size();
	m_vecInstructions.push_back(node);
}

std::set<DWORD> GraphBuilder::LinkJumps()
{
	std::set<DWORD> setRetIndex;
	
	// Link
	for (size_t instructionIndex = 0; instructionIndex < m_vecInstructions.size(); instructionIndex++)
	{
		InstructionNode* pNode = &m_vecInstructions[instructionIndex];

		DWORD dwJumpIndex = 0;
		bool bUnknownJump = true;

		if (pNode->strOpCode.empty())
			continue;

		// Iterate each operand
		for (auto& strOperand : pNode->liRawOperands)
		{
			// Find register
			auto liSubOperandParts = Wrapper::Split(strOperand, "", false, true);
			for (auto& strSubOperand : liSubOperandParts)
			{
				if (REGISTERS_MAP.find(strSubOperand) != REGISTERS_MAP.end())
					pNode->liRegisterOperands.push_back(REGISTERS_MAP.at(strSubOperand));
			}

			if (pNode->strOpCode.front() != 'j' && pNode->strOpCode.find("call") == pNode->strOpCode.npos)
				continue;

			// Skip finding imm if found jump address
			if (!bUnknownJump)
				continue;

			// Find imm in case no pointer
			if (strOperand.find('[') != strOperand.npos || strOperand.find(']') != strOperand.npos)
				continue;

			// Remove dummy
			if (strOperand.back() == 'h')
				strOperand.erase(strOperand.length() - 1);
			if (liSubOperandParts.size() == 2)
				strOperand = liSubOperandParts.back();

			// Is hex
			if (!Wrapper::CheckHexString(strOperand, false))
				continue;

			// Convert to number
			DWORD64 qwImm = std::stoll(strOperand, NULL, 16);

			// Out of range
			if (qwImm < std::next(m_vecInstructions.begin())->qwAddress || qwImm > std::prev(m_vecInstructions.end())->qwAddress)
				continue;

			// Found
			if (m_mapAddressToIndex.find(qwImm) != m_mapAddressToIndex.end())
			{
				dwJumpIndex = m_mapAddressToIndex[qwImm];
				bUnknownJump = false;
			}
			// Not found
			else
			{
				bUnknownJump = false;
			}
		}

		// Next instruction address
		DWORD dwNextIndex = 0;
		bool bHasNextAddress = false;
		if (instructionIndex + 1 < m_vecInstructions.size())
		{
			dwNextIndex = instructionIndex + 1;
			bHasNextAddress = true;
		}

		// Jump
		if (pNode->strOpCode.front() == 'j')
		{
			// Add jump address
			pNode->setNextIndex.insert(dwJumpIndex);
			m_vecInstructions[dwJumpIndex].setPrevIndex.insert(instructionIndex);

			// Add next address
			if (pNode->strOpCode != "jmp" && bHasNextAddress && dwNextIndex != dwJumpIndex)
			{
				pNode->setNextIndex.insert(dwNextIndex);
				m_vecInstructions[dwNextIndex].setPrevIndex.insert(instructionIndex);
			}
		}
		// Call
		else if (pNode->strOpCode.find("call") != pNode->strOpCode.npos)
		{
			// Add jump address
			pNode->setNextIndex.insert(dwJumpIndex);
			m_vecInstructions[dwJumpIndex].setPrevIndex.insert(instructionIndex);
		}
		// Ret
		else if (pNode->strOpCode.find("ret") != pNode->strOpCode.npos)
		{
			// Later
			setRetIndex.insert(instructionIndex);
		}
		// Linear
		else
		{
			if (bHasNextAddress)
			{
				pNode->setNextIndex.insert(dwNextIndex);
				m_vecInstructions[dwNextIndex].setPrevIndex.insert(instructionIndex);
			}
		}
	}

	return setRetIndex;
}

void GraphBuilder::SetDirectPrevForTraceStack(std::stack<DWORD>& stkTrace, DWORD dwIndex)
{
	if (!stkTrace.empty())
	{
		stkTrace.pop();

		while (!stkTrace.empty())
		{
			m_vecInstructions[stkTrace.top()].dwDirectPrevIndex = dwIndex;
			m_vecInstructions[stkTrace.top()].bHasDirectPrev = true;
			stkTrace.pop();
		}
	}
}

void GraphBuilder::TraceCall(DWORD dwRetIndex, DWORD dwIndex, std::stack<DWORD>& stkTrace, std::set<DWORD>& setTraveledIndex, bool bTracing)
{	
	InstructionNode* pCurrentNode = &m_vecInstructions[dwIndex];

	stkTrace.push(dwIndex);
	//std::cout << m_vecInstructions[dwIndex].qwAddress;
	
	if (setTraveledIndex.find(dwIndex) != setTraveledIndex.end())
	{
		//std::cout << ' ' << "Traveled" << std::endl;
		
		if (bTracing)
			SetDirectPrevForTraceStack(stkTrace, dwIndex);
	}
	else
	{
		setTraveledIndex.insert(dwIndex);

		if (pCurrentNode->bHasDirectPrev)
		{
			//std::cout << ' ' << "Direct" << std::endl;
			
			TraceCall(dwRetIndex, pCurrentNode->dwDirectPrevIndex, stkTrace, setTraveledIndex, false);
		}
		else
		{
			// Meet call instruction
			if (pCurrentNode->strOpCode.find("call") != pCurrentNode->strOpCode.npos)
			{
				//std::cout << ' ' << "Call" << std::endl;
				
				if (bTracing)
					SetDirectPrevForTraceStack(stkTrace, dwIndex);

				if (dwIndex + 1 < m_vecInstructions.size())
				{
					// Link next of ret is call
					m_vecInstructions[dwRetIndex].setNextRetIndex.insert(dwIndex + 1);
					m_vecInstructions[dwIndex + 1].setPrevRetIndex.insert(dwRetIndex);
				}
			}
			// No more prev
			else if (!pCurrentNode->setPrevIndex.size())
			{
				//std::cout << ' ' << "No more" << std::endl;
				
				if (bTracing)
					SetDirectPrevForTraceStack(stkTrace, dwIndex);
			}
			// Linear
			else if (pCurrentNode->setPrevIndex.size() == 1)
			{
				//std::cout << ' ' << "Linear" << std::endl;
				
				// Trace prev
				TraceCall(dwRetIndex, *pCurrentNode->setPrevIndex.begin(), stkTrace, setTraveledIndex, bTracing);
			}
			// Multiple prev nodes
			else
			{
				//std::cout << ' ' << "Multiple" << std::endl;
				
				if (bTracing)
					SetDirectPrevForTraceStack(stkTrace, dwIndex);
				
				// Trace each prev node
				for (DWORD dwPrevIndex : pCurrentNode->setPrevIndex)
				{
					// Trace prev
					TraceCall(dwRetIndex, dwPrevIndex, stkTrace, setTraveledIndex, bTracing);
				}
			}
		}
	}

	if (!stkTrace.empty() && stkTrace.top() == dwIndex)
		stkTrace.pop();
}

void GraphBuilder::LinkRets(const std::set<DWORD>& setRetIndex)
{
	// Link ret
	for (auto& dwRetIndex : setRetIndex)
	{
		std::stack<DWORD> stkTrace;
		std::set<DWORD> setTraveledIndex;
				
		TraceCall(dwRetIndex, dwRetIndex, stkTrace, setTraveledIndex, true);
	}
}

void GraphBuilder::MergeRetLinking()
{
	for (auto& node : m_vecInstructions)
	{
		if (!node.setNextRetIndex.empty())
		{
			node.setNextIndex.insert(node.setNextRetIndex.begin(), node.setNextRetIndex.end());
			node.setNextRetIndex.clear();
		}

		if (!node.setPrevRetIndex.empty())
		{
			node.setPrevIndex.insert(node.setPrevRetIndex.begin(), node.setPrevRetIndex.end());
			node.setPrevRetIndex.clear();
		}

		continue;
	}
}

GraphBuilder::GraphBuilder(const std::string& strFilePath)
{
	m_strFilePath = strFilePath;
}

void GraphBuilder::Build()
{
	// Init unknown node
	InstructionNode unknownNode(MAXDWORD64);
	m_mapAddressToIndex[MAXDWORD64] = m_vecInstructions.size();
	m_vecInstructions.push_back(unknownNode);

	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	// Skip header
	std::getline(inFile, strLine);

	// Content
	while (std::getline(inFile, strLine))
		BuildNodes(strLine);

	inFile.close();

	// Link jumps
	std::set<DWORD> setRetAddress;
	setRetAddress = LinkJumps();

	// Link rets
	LinkRets(setRetAddress);

	// Merge ret linking
	MergeRetLinking();
	
	return;
}

void GraphBuilder::PrintGraph()
{
	for (auto& node : m_vecInstructions)
	{
		auto pNode = &node;
		std::cout << pNode->qwAddress << ' ' << pNode->strOpCode << std::endl;

		std::cout << "Next: ";
		for (auto dwIndex : pNode->setNextIndex)
			std::cout << m_vecInstructions[dwIndex].qwAddress << ' ';
		std::cout << std::endl;

		std::cout << "Prev: ";
		for (auto dwIndex : pNode->setPrevIndex)
			std::cout << m_vecInstructions[dwIndex].qwAddress << ' ';
		std::cout << std::endl;

		std::cout << "Direct: ";
		if (pNode->bHasDirectPrev)
			std::cout << m_vecInstructions[pNode->dwDirectPrevIndex].qwAddress;
		else
			std::cout << -1;
		std::cout << std::endl;

		std::cout << std::endl;
	}

	return;
}
