#include "pch.h"
#include "Disassembler.h"
#include "Wrapper.h"

Disassembler::Disassembler(const std::string& strPeFilePath)
{
	m_strPeFilePath = strPeFilePath;
}

bool Disassembler::GenerateAsmFile(const std::string& strDirectory)
{
	std::filesystem::path tmpFilePath = "";

	bool bResult = false;
	do
	{
		if (!exists(std::filesystem::path(m_strPeFilePath)))
			break;
		
		CHAR szTempDir[MAX_PATH];
		ExpandEnvironmentStringsA(TEMP_DIR, szTempDir, _countof(szTempDir));
		
		// Build output file path
		do
		{
			tmpFilePath = szTempDir;
			tmpFilePath.append(Wrapper::GenerateRandomGuid());
		} while (exists(tmpFilePath));

		// Build command line
		CHAR szCommandLine[MAX_PATH * 3] = { 0 };
		lstrcatA(szCommandLine, "\"");
		lstrcatA(szCommandLine, DUMPBIN_PATH);
		lstrcatA(szCommandLine, "\"");
		lstrcatA(szCommandLine, " /HEADERS /DISASM /SECTION:.text ");
		lstrcatA(szCommandLine, "\"");
		lstrcatA(szCommandLine, m_strPeFilePath.c_str());
		lstrcatA(szCommandLine, "\"");
		lstrcatA(szCommandLine, " /OUT:");
		lstrcatA(szCommandLine, "\"");
		lstrcatA(szCommandLine, tmpFilePath.u8string().c_str());
		lstrcatA(szCommandLine, "\"");

		// Start process
		STARTUPINFOA startupInfo = { 0 };
		startupInfo.cb = sizeof(startupInfo);
		PROCESS_INFORMATION processInfo = { 0 };
		if (!CreateProcessA(
			DUMPBIN_PATH,
			szCommandLine, 
			NULL, 
			NULL, 
			FALSE, 
			CREATE_NO_WINDOW, 
			NULL, 
			NULL,
			&startupInfo, &processInfo))
			break;
		
		// Wait
		WaitForSingleObject(processInfo.hProcess, INFINITE);

		// Check
		if (!exists(tmpFilePath))
			break;

		std::filesystem::path outputFilePath = Wrapper::GenerateUniquePath(
			strDirectory, 
			m_strPeFilePath, 
			ASM_EXT);

		std::filesystem::copy_file(tmpFilePath, outputFilePath);
		
		bResult = true;
	} while (false);

	if (exists(tmpFilePath))
		std::filesystem::remove(tmpFilePath);
	
	return bResult;
}