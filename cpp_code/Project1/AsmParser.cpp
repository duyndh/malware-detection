#include "pch.h"
#include "AsmParser.h"

#include "Wrapper.h"

AsmParser::AsmParser(const std::string& strFilePath, bool bIdaAsm)
{
	m_strFilePath = strFilePath;
	m_asmInfo.mapInstructions.clear();
	m_asmInfo.machine = MachineType_UNKNOWN;
	m_asmInfo.qwImageBase = 0;
}

bool AsmParser::GetHeaderInfo(const std::string& strLine)
{
	if (m_asmInfo.machine == MachineType_UNKNOWN)
	{
		size_t iFormatPos = strLine.find("Format");
		if (iFormatPos != strLine.npos)
		{
			size_t iPePos = strLine.find("(PE)", iFormatPos);
			if (iPePos != strLine.npos)
			{
				for (auto& paMachine : m_MAP_MACHINE_TYPE)
				{
					if (strLine.find(paMachine.second, iFormatPos) != strLine.npos)
					{
						m_asmInfo.machine = paMachine.first;
						return true;
					}
				}				
			}

			return false;
		}
	}

	if (!m_asmInfo.qwImageBase)
	{
		size_t iImgBasePos = strLine.find("Imagebase");
		if (iImgBasePos != strLine.npos)
		{
			auto liParts = Wrapper::Split(strLine.substr(iImgBasePos));
			if (liParts.size() > 0)
			{
				if (Wrapper::CheckHexString(liParts.back()))
				{
					m_asmInfo.qwImageBase = std::stoull(liParts.back(), NULL, 16);
					return true;
				}
			}

			return false;
		}
	}
	
	return true;
}

bool AsmParser::ParseLine(std::string strLine)
{
	const std::string strTextSection = STR_TEXT_SECTION;

	// Not text section
	if (strLine.find(strTextSection) != 0)
		return false;

	// Remove comments
	if (strLine.find_first_of(';') != strLine.npos)
		strLine.erase(strLine.find_first_of(';'));

	// Split
	auto liParts = Wrapper::Split(strLine.substr(strTextSection.length()));
	if (liParts.size() < 2)
		return false;

	// Check address
	if (!Wrapper::CheckHexString(liParts.front()) || !Wrapper::CheckHexString(*std::next(liParts.begin())))
		return false;
	DWORD64 qwAddress = std::stoull(liParts.front(), NULL, 16);
	bool bContinuousIns = m_asmInfo.mapInstructions.find(qwAddress) != m_asmInfo.mapInstructions.end();
	
	// Check pseudo instruction
	bool bPseudoIns = false;
	auto itPseudoOp = liParts.end();
	for (itPseudoOp = liParts.begin(); itPseudoOp != liParts.end(); itPseudoOp++)
	{
		if (m_SET_PSEUDO_OPCODES.find(*itPseudoOp) != m_SET_PSEUDO_OPCODES.end())
		{
			bPseudoIns = true;
			break;
		}
	}
	// Solve '+' case
	if (!bPseudoIns)
	{
		for (auto it = liParts.begin(); it != liParts.end(); it++)
		{
			if (it->back() == '+')
			{
				bPseudoIns = true;
				itPseudoOp = std::next(it);
				break;
			}
		}
	}

	// Continue split when ins is pseudo
	if (bPseudoIns || bContinuousIns)
	{
		for (auto it = liParts.begin(); it != itPseudoOp; it++)
		{
			size_t iPos = it->find('+');
			if (iPos != it->npos)
			{
				std::string strOld = *it;
				it->assign(strOld.substr(0, iPos));
			}
		}
	}

	std::list<BYTE> liBytes;
	std::list<std::string> liOperands;
	std::string strOpcode;

	// Get bytes
	auto it = std::next(liParts.begin());
	for (; it != liParts.end(); it++)
	{
		if (bPseudoIns && it == itPseudoOp)
			break;
		
		if (!Wrapper::CheckHexString(*it))
			break;

		if (it->length() != 2)
			break;

		BYTE bData = std::stoi(*it, NULL, 16);
		liBytes.push_back(bData);
	}
	if (!liBytes.size())
		return false;

	// Get operands
	if (bPseudoIns)
	{
		if (itPseudoOp != liParts.end())
		{
			strOpcode = *itPseudoOp;
			it = std::next(itPseudoOp);
		}
		else
			it = liParts.end();
	}
	else if (it != liParts.end())
	{
		strOpcode = *it;
		it++;
	}
	
	if (it != liParts.end())
		liOperands.insert(liOperands.begin(), it, liParts.end());

	if (bContinuousIns)
	{
		// Bytes
		m_asmInfo.mapInstructions[qwAddress].liBytes.insert(
			m_asmInfo.mapInstructions[qwAddress].liBytes.end(),
			liBytes.begin(), liBytes.end()
		);

		// Ops
		m_asmInfo.mapInstructions[qwAddress].liOperands.insert(
			m_asmInfo.mapInstructions[qwAddress].liOperands.end(),
			liOperands.begin(), liOperands.end()
		);
	}
	else
	{
		Instruction ins;
		ins.liBytes = liBytes;
		ins.strOpcode = strOpcode;
		ins.liOperands = liOperands;

		// New
		m_asmInfo.mapInstructions.insert({ qwAddress, ins });

		m_setOpCodes.insert(strOpcode);
	}

	return true;
}

bool AsmParser::Parse()
{
	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	// Get header info
	while (std::getline(inFile, strLine))
	{
		if (!GetHeaderInfo(strLine))
			break;

		if (m_asmInfo.machine != MachineType_UNKNOWN && m_asmInfo.qwImageBase)
			break;
	}

	auto machineName = (m_asmInfo.machine != MachineType_UNKNOWN ? m_MAP_MACHINE_TYPE.at(m_asmInfo.machine) : "Unknown");
	Wrapper::Log(
		machineName
		+ " " + Wrapper::GetHexString(m_asmInfo.qwImageBase)
		+ " " + m_strFilePath);

	if (m_asmInfo.machine == MachineType_UNKNOWN)
		return false;
	else
		auto strMachineName = m_MAP_MACHINE_TYPE.at(m_asmInfo.machine);
	
	// Disasm
	while (std::getline(inFile, strLine))
	{
		ParseLine(strLine);
	}

	inFile.close();	
	return true;
}

void AsmParser::ExportToCsvFile(const std::string& strDirectory)
{
	// Build output file path
	std::stringstream ssFileName;
	ssFileName << m_asmInfo.machine;
	ssFileName << "_";
	ssFileName << std::hex << m_asmInfo.qwImageBase;
	ssFileName << "_";
	ssFileName << std::filesystem::path(m_strFilePath).filename();

	std::string strOutputFilePath = Wrapper::GenerateUniquePath(strDirectory, ssFileName.str(), CSV_EXT);
		
	std::ofstream f(strOutputFilePath);

	// Instructions
	for (const auto& ins : m_asmInfo.mapInstructions)
	{
		// Address
		f << std::hex << ins.first;

		// Opcode
		f << CSV_DELIM << ins.second.strOpcode;
				
		// Operands
		f << CSV_DELIM;
		for (const auto& op : ins.second.liOperands)
			f << ' ' << op;

		// Bytes
		std::vector<BYTE> vecBuffer(ins.second.liBytes.begin(), ins.second.liBytes.end());
		f << CSV_DELIM << Wrapper::EncodeBase64(vecBuffer.data(), vecBuffer.size());

		// Endline
		f << "\n";
	}

	f.close();
	
	return;
}
