#include "pch.h"
#include "Wrapper.h"

void Wrapper::Log(const std::string& strMessage)
{
	std::ofstream f(LOG_FILE_PATH, std::ios::app);
	f << strMessage << "\n";
	f.close();
}

std::string Wrapper::GetHexString(DWORD64 qwNumber)
{
	std::stringstream sstream;
	sstream << std::hex << qwNumber;
	
	std::string str(sstream.str());
	return str;
}

std::string Wrapper::EncodeBase64(LPBYTE pBuffer, DWORD dwBufferSize)
{
	DWORD dwBase64Length = 0;
	LPSTR szBase64 = NULL;

	std::string strBase64 = "";

	bool bResult = false;
	do
	{
		CryptBinaryToStringA(pBuffer, dwBufferSize, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &dwBase64Length);
		if (!dwBase64Length)
			break;

		szBase64 = (LPSTR)LocalAlloc(LPTR, dwBase64Length);

		if (!CryptBinaryToStringA(pBuffer, dwBufferSize, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, szBase64, &dwBase64Length))
			break;

		if (!dwBase64Length)
			break;

		strBase64 = szBase64;
		
		bResult = true;
	} while (false);
		
	if (szBase64)
		LocalFree(szBase64);
	
	if (bResult)
		return strBase64;
	else
		return "";
}

std::list<std::string> Wrapper::Split(const std::string& strLine)
{
	std::list<std::string> liParts;
	const std::set<char> setDelims = { ' ', '\t', ',' };

	for (size_t iBegin = 0; iBegin < strLine.length(); iBegin++)
	{
		if (setDelims.find(strLine[iBegin]) == setDelims.end())
		{
			size_t iDelim = iBegin + 1;
			for (; iDelim < strLine.length(); iDelim++)
			{
				if (setDelims.find(strLine[iDelim]) != setDelims.end())
					break;
			}
			liParts.push_back(strLine.substr(iBegin, iDelim - iBegin));

			iBegin = iDelim;
		}
	}

	return liParts;
}

bool Wrapper::CheckHexString(const std::string& str)
{
	bool bHexString = true;
	for (char c : str)
	{
		//c = std::tolower(c);
		if ((c < '0' || c > '9') && (c < 'A' || c > 'F'))
		{
			bHexString = false;
			break;
		}
	}
	return bHexString;
}

std::list<std::string> Wrapper::RecursiveEnumFiles(const std::string& strDirectory, const std::set<std::string>& setExtensions)
{
	std::list<std::string> liPaths;
	
	for (const auto& file : std::filesystem::recursive_directory_iterator(strDirectory))
	{
		if (file.is_directory())
			continue;

		std::string strFilePath = file.path().u8string();
		std::transform(strFilePath.begin(), strFilePath.end(), strFilePath.begin(), [](char c) { return std::tolower(c); });

		std::filesystem::path filePath = strFilePath;
		if (setExtensions.find(filePath.extension().u8string()) == setExtensions.end())
			continue;

		liPaths.push_back(filePath.u8string());
	}

	return liPaths;
}

