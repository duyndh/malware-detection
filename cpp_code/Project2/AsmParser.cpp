#include "pch.h"
#include "AsmParser.h"
#include "Wrapper.h"

AsmParser::AsmParser(const std::string& strFilePath, bool bIdaAsm)
{
	m_strFilePath = strFilePath;
	m_asmInfo.mapInstructions.clear();
	m_asmInfo.machine = MachineType_UNKNOWN;
	m_asmInfo.qwImageBase = 0;
	m_bIdaAsm = bIdaAsm;
}

MachineType AsmParser::GetMachineType()
{
	return m_asmInfo.machine;
}

DWORD64 AsmParser::GetImageBase()
{
	return m_asmInfo.qwImageBase;
}

bool AsmParser::GetHeaderInfo()
{
	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	while (std::getline(inFile, strLine))
	{
		if (m_asmInfo.machine == MachineType_UNKNOWN)
		{
			size_t iFormatPos = strLine.find("Format");
			if (iFormatPos != strLine.npos)
			{
				size_t iPePos = strLine.find("(PE)", iFormatPos);
				if (iPePos != strLine.npos)
				{
					for (auto& paMachine : m_MAP_MACHINE_TYPE)
					{
						if (strLine.find(paMachine.second, iFormatPos) != strLine.npos)
						{
							m_asmInfo.machine = paMachine.first;
							break;
						}
					}
				}

				break;
			}
		}

		if (!m_asmInfo.qwImageBase)
		{
			size_t iImgBasePos = strLine.find("Imagebase");
			if (iImgBasePos != strLine.npos)
			{
				auto liParts = Wrapper::Split(strLine.substr(iImgBasePos));
				if (!liParts.empty())
				{
					if (Wrapper::CheckHexString(liParts.back()))
					{
						m_asmInfo.qwImageBase = std::stoull(liParts.back(), NULL, 16);
					}
				}

				break;
			}
		}
	}
	inFile.close();
	return (m_asmInfo.machine != MachineType_UNKNOWN && m_asmInfo.qwImageBase);
}

bool AsmParser::GetNativeHeaderInfo()
{
	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	while (std::getline(inFile, strLine))
	{
		if (m_asmInfo.machine == MachineType_UNKNOWN)
		{
			if (strLine.find("machine") != strLine.npos)
			{
				if (strLine.find("14C") != strLine.npos
					&& strLine.find("(x86)") != strLine.npos)
				{
					m_asmInfo.machine = MachineType_X86;
				}
				else if (strLine.find("8664") != strLine.npos
					&& strLine.find("(x64)") != strLine.npos)
				{
					m_asmInfo.machine = MachineType_X64;
				}
				else
					break;
			}
		}
		if (!m_asmInfo.qwImageBase)
		{
			if (strLine.find("image base") != strLine.npos)
			{
				auto liParts = Wrapper::Split(strLine);
				if (liParts.size() >= 3 && Wrapper::CheckHexString(liParts.front()))
				{
					m_asmInfo.qwImageBase = std::stoull(liParts.front(), NULL, 16);
				}
				else
					break;
			}
		}

		if (m_asmInfo.machine != MachineType_UNKNOWN && m_asmInfo.qwImageBase)
			break;
	}
	
	inFile.close();
	return (m_asmInfo.machine != MachineType_UNKNOWN && m_asmInfo.qwImageBase);
}

bool AsmParser::ParseLine(std::string strLine)
{
	const std::string strTextSection = STR_TEXT_SECTION;

	// Not text section
	if (strLine.find(strTextSection) != 0)
		return false;

	// Remove comments
	if (strLine.find_first_of(';') != strLine.npos)
		strLine.erase(strLine.find_first_of(';'));

	// Split
	auto liParts = Wrapper::Split(strLine.substr(strTextSection.length()));
	if (liParts.size() < 2)
		return false;

	// Check address
	if (!Wrapper::CheckHexString(liParts.front()) || !Wrapper::CheckHexString(*std::next(liParts.begin())))
		return false;
	DWORD64 qwAddress = std::stoull(liParts.front(), NULL, 16);
	bool bContinuousIns = m_asmInfo.mapInstructions.find(qwAddress) != m_asmInfo.mapInstructions.end();
	
	// Check pseudo instruction
	bool bPseudoIns = false;
	auto itPseudoOp = liParts.end();
	for (itPseudoOp = liParts.begin(); itPseudoOp != liParts.end(); itPseudoOp++)
	{
		if (m_SET_PSEUDO_OPCODES.find(*itPseudoOp) != m_SET_PSEUDO_OPCODES.end())
		{
			bPseudoIns = true;
			break;
		}
	}
	// Solve '+' case
	if (!bPseudoIns)
	{
		for (auto it = liParts.begin(); it != liParts.end(); it++)
		{
			if (it->back() == '+')
			{
				bPseudoIns = true;
				itPseudoOp = std::next(it);
				break;
			}
		}
	}

	// Continue split when ins is pseudo
	if (bPseudoIns || bContinuousIns)
	{
		for (auto it = liParts.begin(); it != itPseudoOp; it++)
		{
			size_t iPos = it->find('+');
			if (iPos != it->npos)
			{
				std::string strOld = *it;
				it->assign(strOld.substr(0, iPos));
			}
		}
	}

	std::list<BYTE> liBytes;
	std::list<std::string> liOperands;
	std::string strOpcode;

	// Get bytes
	auto it = std::next(liParts.begin());
	for (; it != liParts.end(); it++)
	{
		if (bPseudoIns && it == itPseudoOp)
			break;
		
		if (!Wrapper::CheckHexString(*it))
			break;

		if (it->length() != 2)
			break;

		BYTE bData = std::stoi(*it, NULL, 16);
		liBytes.push_back(bData);
	}
	if (liBytes.empty())
		return false;

	// Get operands
	if (bPseudoIns)
	{
		if (itPseudoOp != liParts.end())
		{
			strOpcode = *itPseudoOp;
			it = std::next(itPseudoOp);
		}
		else
			it = liParts.end();
	}
	else if (it != liParts.end())
	{
		strOpcode = *it;
		it++;
	}
	
	if (it != liParts.end())
		liOperands.insert(liOperands.begin(), it, liParts.end());

	if (bContinuousIns)
	{
		// Bytes
		m_asmInfo.mapInstructions[qwAddress].liBytes.insert(
			m_asmInfo.mapInstructions[qwAddress].liBytes.end(),
			liBytes.begin(), liBytes.end()
		);

		// Ops
		m_asmInfo.mapInstructions[qwAddress].liOperands.insert(
			m_asmInfo.mapInstructions[qwAddress].liOperands.end(),
			liOperands.begin(), liOperands.end()
		);
	}
	else
	{
		Instruction ins;
		ins.liBytes = liBytes;
		ins.strOpcode = strOpcode;
		ins.liOperands = liOperands;

		// New
		m_asmInfo.mapInstructions.insert({ qwAddress, ins });
	}

	return true;
}

bool AsmParser::ParseNativeLine(std::string strLine)
{
	DWORD64 qwAddress = 0;
	std::list<BYTE> liBytes;
	std::list<std::string> liOperands;
	std::string strOpcode;

	// Split
	auto liParts = Wrapper::Split(strLine);
	if (liParts.empty())
		return false;

	// May start with address
	if (strLine.find(':') != strLine.npos)
	{
		if (liParts.size() <= 2)
			return false;
		
		// Get address
		if (liParts.begin()->back() != ':')
			return false;
		std::string strAddress = liParts.front().substr(0, liParts.front().length() - 1);
		if (!Wrapper::CheckHexString(strAddress))
			return false;
		qwAddress = std::stoull(strAddress, NULL, 16);

		// Find opcode
		std::list<std::string>::iterator itOpcode = liParts.end();
		for (auto it = std::next(liParts.begin()); it != liParts.end(); it++)
		{
			if (Wrapper::CheckHexString(*it))
			{
				if (it->length() != 2)
					return false;
			}
			else
			{
				itOpcode = it;
				break;
			}
		}
		if (itOpcode == liParts.end())
			return false;
		strOpcode = *itOpcode;

		for (auto it = std::next(liParts.begin()); it != itOpcode; it++)
		{
			liBytes.push_back((BYTE)std::stoull(*it, NULL, 16));
		}

		for (auto it = std::next(itOpcode); it != liParts.end(); it++)
		{
			liOperands.push_back(*it);
		}
	}
	else
	{
		// Get bytes
		if (std::any_of(liParts.begin(), liParts.end(), [](const std::string& strPart) { return strPart.length() != 2 || !Wrapper::CheckHexString(strPart); }))
			return false;

		if (!m_qwLastAddress || m_asmInfo.mapInstructions.find(m_qwLastAddress) == m_asmInfo.mapInstructions.end())
			return false;

		qwAddress = m_qwLastAddress;
		for (const auto& strPart : liParts)
		{
			liBytes.push_back((BYTE)std::stoi(strPart, NULL, 16));
		}
	}
	if (!qwAddress || liBytes.empty())
		return false;

	// Continous opcode
	if (m_asmInfo.mapInstructions.find(qwAddress) != m_asmInfo.mapInstructions.end())
	{
		m_asmInfo.mapInstructions[m_qwLastAddress].liBytes.insert(
			m_asmInfo.mapInstructions[m_qwLastAddress].liBytes.end(), 
			liBytes.begin(), liBytes.end());
	}
	// New opcode
	else
	{
		if (!strOpcode.length())
			return false;
		
		Instruction ins;
		ins.liBytes = liBytes;
		ins.strOpcode = strOpcode;
		ins.liOperands = liOperands;

		// New
		m_asmInfo.mapInstructions.insert({ qwAddress, ins });
	}

	m_qwLastAddress = qwAddress;
	return true;
}

bool AsmParser::Parse()
{
	if (!GetHeaderInfo())
		return false;

	if (m_asmInfo.machine != MachineType_UNKNOWN && m_asmInfo.qwImageBase)
		return false;
	
	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	/*auto strMachineName = (m_asmInfo.machine != MachineType_UNKNOWN ? m_MAP_MACHINE_TYPE.at(m_asmInfo.machine) : "Unknown");
	Wrapper::Log(
		strMachineName
		+ " " + Wrapper::GetHexString(m_asmInfo.qwImageBase)
		+ " " + m_strFilePath);*/
	
	// Disasm
	while (std::getline(inFile, strLine))
	{
		ParseLine(strLine);
	}

	inFile.close();	
	return true;
}

bool AsmParser::ParseNative()
{
	// Get header info
	if (!GetNativeHeaderInfo())
		return false;

	if (m_asmInfo.machine == MachineType_UNKNOWN || !m_asmInfo.qwImageBase)
		return false;
	
	std::ifstream inFile(m_strFilePath);
	std::string strLine;

	/*auto strMachineName = (m_asmInfo.machine != MachineType_UNKNOWN ? m_MAP_MACHINE_TYPE.at(m_asmInfo.machine) : "Unknown");
	Wrapper::Log(
		strMachineName
		+ " " + Wrapper::GetHexString(m_asmInfo.qwImageBase)
		+ " " + m_strFilePath);*/

	// Disasm
	m_qwLastAddress = 0;
	while (std::getline(inFile, strLine))
	{
		ParseNativeLine(strLine);
	}
	
	inFile.close();

	/*std::set<std::string> setOpcode;
	for (auto& ins : m_asmInfo.mapInstructions)
	{
		setOpcode.insert(ins.second.strOpcode);*/
		/*std::cout << std::hex << ins.first;
		std::cout << '\t' << ins.second.strOpcode << '\t';
		for (auto str : ins.second.liRawOperands)
			std::cout << ' ' << str;
		std::cout << '\t';
		for (WORD b : ins.second.liBytes)
		{
			std::cout << ' ';
			std::cout << std::hex << b;
		}

		std::cout << std::endl;*/
	//}

	//for (auto& op : setOpcode)
	//	std::cout << op << std::endl;

	if (!m_asmInfo.mapInstructions.size())
		return false;
	
	return true;
}

void AsmParser::ExportToCsvFile(const std::string& strDirectory, const std::string& strFileName)
{
	// Build output file path
	std::stringstream ssFileName;
	ssFileName << m_asmInfo.machine;
	ssFileName << "_";
	ssFileName << std::hex << m_asmInfo.qwImageBase;
	ssFileName << "_";
	if (strFileName.length())
		ssFileName << strFileName;
	else
		ssFileName << std::filesystem::path(m_strFilePath).filename();

	std::string strOutputFilePath = Wrapper::GenerateUniquePath(strDirectory, ssFileName.str(), CSV_EXT);
		
	std::ofstream f(strOutputFilePath);

	// Header
	f << "Address" << CSV_DELIM << "Opcode" << CSV_DELIM << "Operands" << CSV_DELIM << "Bytes" << std::endl;
	
	// Instructions
	for (const auto& ins : m_asmInfo.mapInstructions)
	{
		// Address
		f << std::hex << ins.first;

		// Opcode
		f << CSV_DELIM << ins.second.strOpcode;
				
		// Operands
		f << CSV_DELIM;
		for (auto it = ins.second.liOperands.begin(); it != ins.second.liOperands.end(); it++)
		{
			if (it != ins.second.liOperands.begin())
				f << ' ';
			f << *it;
		}

		// Bytes
		std::vector<BYTE> vecBuffer(ins.second.liBytes.begin(), ins.second.liBytes.end());
		f << CSV_DELIM << Wrapper::EncodeBase64(vecBuffer.data(), vecBuffer.size());

		// Endline
		f << std::endl;
	}

	f.close();	
	return;
}
