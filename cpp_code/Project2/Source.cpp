#include "pch.h"
#include "Wrapper.h"
#include "GraphBuilder.h"
#include "Disassembler.h"

void WINAPI EntryPoint()
{
	MessageBoxA(NULL, "Hello", NULL, MB_OK);
}

void WINAPI BuildGraph(const std::string& strCsvFilePath, const std::string& strOutputDirectory)
{
	GraphBuilder graphBuilder(strCsvFilePath);
	graphBuilder.Build();
	//graphBuilder.PrintGraph();
	graphBuilder.ExportCsv(strOutputDirectory);
}

void WINAPI BuildGraphDataset(const std::string& strInputDirectory, const std::string& strOutputDirectory)
{
	std::cout << "Directory: " << strInputDirectory << std::endl;
	auto liPaths = Wrapper::RecursiveEnumFiles(strInputDirectory, { CSV_EXT });
	std::cout << "Total: " << liPaths.size() << std::endl;

	size_t iPath = 1;
	for (auto& strPath : liPaths)
	{
		std::cout << iPath << "/" << liPaths.size() << ": " << strPath << std::endl;

		try
		{
			BuildGraph(strPath, strOutputDirectory);
		}
		catch (std::exception ex) {}
		
		iPath++;
	}

	std::cout << "Done" << std::endl;
}

void WINAPI LoadCsvGraph(const std::string& strFilePath, const std::string& strEnvName)
{
	//std::ifstream inFile(strFilePath);
	//std::string strLine;

	//std::list<std::tuple<BYTE, std::vector<DWORD>>> liCsvData;
	//
	//// Skip header
	//std::getline(inFile, strLine);

	//// Content
	//while (std::getline(inFile, strLine))
	//{
	//	// To lower
	//	std::transform(strLine.begin(), strLine.end(), strLine.begin(), [](unsigned char c) { return std::tolower(c); });

	//	// Split csv line
	//	auto liParts = Wrapper::Split(strLine, ",");
	//	if (liParts.size() < 3)
	//		return;

	//	auto itPart = liParts.begin();
	//	
	//	// Opcode
	//	BYTE bOpcode = std::stoull(*itPart, NULL, 16);
	//	itPart = std::next(itPart);
	//	
	//	// Register
	//	itPart = std::next(itPart);
	//	
	//	// Next
	//	auto vecNextIndexInBytes = Wrapper::DecodeBase64(*itPart);
	//	std::vector<DWORD> vecNextIndexes;
	//	vecNextIndexes.reserve(vecNextIndexInBytes.size());

	//	// Add
	//	//liCsvData.push_back(std::make_tuple(bOpcode, ));
	//}
	//
	//inFile.close();
}

void WINAPI AsmToGraph(const std::string& strAsmFilePath, bool bIdaAsm)
{
	AsmParser asmParser(strAsmFilePath, bIdaAsm);
	if (bIdaAsm)
		asmParser.Parse();
	else
		asmParser.ParseNative();
	auto asmBlocks = asmParser.ExportToBlocks();

	GraphBuilder graphBuilder("");
	graphBuilder.BuildFromBlocks(asmBlocks);
	auto graphBlocks = graphBuilder.ExportToBlocks();

	// Get buffer
	std::vector<BYTE> vecBuffer;

	DWORD dwTotalSize = 0;
	for (auto& block : graphBlocks)
		dwTotalSize += (sizeof(BYTE) + block.vecRegisterOperands.size() * sizeof(BYTE) + sizeof(DWORD) * block.vecNextIndexes.size() + sizeof(DWORD));
	vecBuffer.resize(dwTotalSize);
	
	DWORD dwOffset = 0;
	for (auto& block : graphBlocks)
	{
		vecBuffer.data()[dwOffset++] = block.bOpcode;
		
		memcpy(&vecBuffer.data()[dwOffset], block.vecRegisterOperands.data(), block.vecRegisterOperands.size());
		dwOffset += block.vecRegisterOperands.size();

		memcpy(&vecBuffer.data()[dwOffset], block.vecNextIndexes.data(), block.vecNextIndexes.size());
		dwOffset += block.vecNextIndexes.size() * sizeof(DWORD);

		*(LPDWORD)(vecBuffer.data() + dwOffset) = block.dwDirectPrevIndex;
		dwOffset += sizeof(DWORD);
	}

	HKEY hKey = NULL;
	do
	{
		if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_CURRENT_USER, ROOT_REGISTRY_SUBKEY, 0, KEY_ALL_ACCESS, &hKey))
			break;

		if (ERROR_SUCCESS != RegSetValueExA(hKey, GRAPH_DATA_REGISTRY_NAME, 0, REG_BINARY, vecBuffer.data(), vecBuffer.size()))
			break;

	} while (false);

	if (hKey)
		RegCloseKey(hKey);	
}

void WINAPI FileToGraph(const std::string& strPeFilePath)
{
	Disassembler disasm(strPeFilePath);
	std::string strTmpAsmPath = disasm.GenerateAsmFile("");

	AsmToGraph(strTmpAsmPath, false);

	if (std::filesystem::exists(strTmpAsmPath))
		DeleteFileA(strTmpAsmPath.c_str());

	return;
}

void WINAPI FileToGraphCsv(LPSTR strPeFilePath, LPSTR strOutputFileName)
{
	Disassembler disasm(strPeFilePath);
	std::string strAsmPath = disasm.GenerateAsmFile("");

	CHAR szTemp[MAX_PATH];
	ExpandEnvironmentStringsA(TEMP_DIR, szTemp, _countof(szTemp));
	
	AsmParser asmParser(strAsmPath, false);
	asmParser.ParseNative();
	std::string strParserFilePath = asmParser.ExportToCsvFile(szTemp, "");

	GraphBuilder graphBuilder(strParserFilePath);
	graphBuilder.Build();
	std::string strGraphFilePath = graphBuilder.ExportCsv(szTemp);

	CopyFileA(strGraphFilePath.c_str(), std::filesystem::path(szTemp).append(strOutputFileName).u8string().c_str(), false);

	if (PathFileExistsA(strGraphFilePath.c_str()))
		DeleteFileA(strGraphFilePath.c_str());

	//HKEY hKey = NULL;
	//do
	//{
	//	if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_CURRENT_USER, ROOT_REGISTRY_SUBKEY, 0, KEY_WRITE, &hKey))
	//		break;

	//	if (ERROR_SUCCESS != RegSetValueExA(hKey, GRAPH_DATA_REGISTRY_NAME, 0, REG_SZ, (LPBYTE)strGraphFilePath.c_str(), strGraphFilePath.size()))
	//		break;		

	//} while (false);

	//if (hKey)
	//	RegCloseKey(hKey);
}