#include "pch.h"
#include "Wrapper.h"

void Wrapper::Log(const std::string& strMessage)
{
	std::ofstream f(LOG_FILE_PATH, std::ios::app);
	f << strMessage << "\n";
	f.close();
}

std::string Wrapper::GetHexString(DWORD64 qwNumber)
{
	std::stringstream sstream;
	sstream << std::hex << qwNumber;
	
	std::string str(sstream.str());
	return str;
}

std::string Wrapper::EncodeBase64(LPBYTE pBuffer, DWORD dwBufferSize)
{
	DWORD dwBase64Length = 0;
	LPSTR szBase64 = NULL;

	std::string strBase64 = "";

	bool bResult = false;
	do
	{
		CryptBinaryToStringA(pBuffer, dwBufferSize, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &dwBase64Length);
		if (!dwBase64Length)
			break;

		szBase64 = (LPSTR)LocalAlloc(LPTR, dwBase64Length);

		if (!CryptBinaryToStringA(pBuffer, dwBufferSize, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, szBase64, &dwBase64Length))
			break;

		if (!dwBase64Length)
			break;

		strBase64 = szBase64;
		
		bResult = true;
	} while (false);
		
	if (szBase64)
		LocalFree(szBase64);
	
	if (bResult)
		return strBase64;
	else
		return "";
}

std::vector<BYTE> Wrapper::DecodeBase64(const std::string& strBase64)
{
	std::vector<BYTE> vecBuffer;

	bool bResult = false;
	do
	{
		DWORD dwBufferLength = 0;
		CryptStringToBinaryA(strBase64.c_str(), NULL, CRYPT_STRING_BASE64, NULL, &dwBufferLength, NULL, NULL);
		if (!dwBufferLength)
			break;

		vecBuffer.resize(dwBufferLength);
		if (!CryptStringToBinaryA(strBase64.c_str(), NULL, CRYPT_STRING_BASE64, vecBuffer.data(), &dwBufferLength, NULL, NULL))
			break;

		if (!dwBufferLength)
			break;

		bResult = true;
	} while (false);

	if (!bResult)
		vecBuffer.clear();
	
	return vecBuffer;
}

std::list<std::string> Wrapper::Split(const std::string& strLine, const std::string& strDelims, bool bAcceptEmptyPart, bool bAlphaNum)
{
	std::list<std::string> liParts;
	std::set<char> setDelims = { ' ', '\t', ',' };
	if (bAlphaNum)
	{
		setDelims.clear();
		for (WORD c = 0; c < 256; c++)
		{
			if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z') && (c < '0' || c > '9'))
				setDelims.insert(c);
		}
	}
	else if(strDelims.length())
	{
		setDelims.clear();
		setDelims.insert(strDelims.begin(), strDelims.end());
	}

	for (size_t iBegin = 0; iBegin < strLine.length(); iBegin++)
	{
		if (setDelims.find(strLine[iBegin]) == setDelims.end())
		{
			size_t iDelim = iBegin + 1;
			for (; iDelim < strLine.length(); iDelim++)
			{
				if (setDelims.find(strLine[iDelim]) != setDelims.end())
					break;
			}
			liParts.push_back(strLine.substr(iBegin, iDelim - iBegin));

			iBegin = iDelim;
		}
		else if (bAcceptEmptyPart)
			liParts.push_back("");
	}

	return liParts;
}

DWORD Wrapper::GetFileCheckSum(const std::string& strFilePath)
{
	DWORD dwOriginChecksum = 0;
	DWORD dwComputedChecksum = 0;
	MapFileAndCheckSumA(strFilePath.c_str(), &dwOriginChecksum, &dwComputedChecksum);

	return dwComputedChecksum;
}

bool Wrapper::CheckHexString(const std::string& str, bool bCaseSensitive)
{
	bool bHexString = true;
	for (char c : str)
	{
		if (!bCaseSensitive)
			c = std::toupper(c);
		
		if ((c < '0' || c > '9') && (c < 'A' || c > 'F'))
		{
			bHexString = false;
			break;
		}
	}
	return bHexString;
}

std::list<std::string> Wrapper::RecursiveEnumFiles(const std::string& strDirectory, const std::set<std::string>& setExtensions)
{
	std::list<std::string> liPaths;

	CHAR szExpandedDirectory[MAX_PATH];
	ExpandEnvironmentStringsA(strDirectory.c_str(), szExpandedDirectory, _countof(szExpandedDirectory));
	
	for (const auto& file : std::filesystem::recursive_directory_iterator(szExpandedDirectory))
	{
		std::string strFilePath = file.path().u8string();
		
		if (FILE_ATTRIBUTE_DIRECTORY == PathIsDirectoryA(strFilePath.c_str()))
			continue;
		
		std::transform(strFilePath.begin(), strFilePath.end(), strFilePath.begin(),
			[](char c) { return std::tolower(c); });

		if (setExtensions.find(std::filesystem::path(strFilePath).extension().u8string()) == setExtensions.end())
			continue;

		liPaths.push_back(strFilePath);
	}

	return liPaths;
}

std::list<std::string> Wrapper::NativeRecursiveEnumFiles(const std::string& strDirectory,
	const std::set<std::string>& setExtensions)
{
	std::queue<std::string> quDirectorires;
	std::list<std::string> liPaths;

	CHAR wzExpandedDirectory[MAX_PATH] = {0};
	ExpandEnvironmentStringsA(strDirectory.c_str(), wzExpandedDirectory, _countof(wzExpandedDirectory));
	
	quDirectorires.push(wzExpandedDirectory);
	while (!quDirectorires.empty())
	{
		std::string strRootDirectory = quDirectorires.front();
		quDirectorires.pop();
		
		WIN32_FIND_DATAA findFileData;
		HANDLE hFind = FindFirstFileA((std::filesystem::path(strRootDirectory).append("*.*").u8string()).c_str(), &findFileData);
		if (INVALID_HANDLE_VALUE != hFind)
		{
			do
			{
				if (std::string(".") == findFileData.cFileName || std::string("..") == findFileData.cFileName)
				{
					// Skip
				}
				else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					quDirectorires.push(std::filesystem::path(strRootDirectory).append(findFileData.cFileName).u8string());
				}
				else
				{
					std::string strFilePath = findFileData.cFileName;
					std::transform(strFilePath.begin(), strFilePath.end(), strFilePath.begin(),
						[](char c) { return std::tolower(c); });

					if (setExtensions.find(std::filesystem::path(strFilePath).extension().u8string()) != setExtensions.end())
						liPaths.push_back(std::filesystem::path(strRootDirectory).append(strFilePath).u8string());
				}

			} while (FindNextFileA(hFind, &findFileData));

			FindClose(hFind);
		}
	}
	
	return liPaths;
}

std::string Wrapper::GenerateRandomGuid()
{
	GUID guid = {0};
	CoCreateGuid(&guid);

	LPOLESTR guidString;
	StringFromCLSID(guid, &guidString);
	std::string strGuid(guidString, guidString + wcslen(guidString));

	CoTaskMemFree(guidString);
	
	return strGuid;
}

std::string Wrapper::GenerateUniquePath(const std::string& strDirectory, const std::string& strFileName, const std::string& strExt)
{
	std::string strAlterFileName = [&]() { auto str = strFileName; for (auto& c : str) if (!std::isalnum(c)) c = '_'; return str; }();

	std::filesystem::path alterFilePath;

	for (size_t index = 0;; index++)
	{
		if (strDirectory.length())
			alterFilePath = strDirectory;
		else
			alterFilePath = "";
		
		alterFilePath.append(strAlterFileName.c_str() + std::to_string(index) + strExt);

		if (!std::filesystem::exists(alterFilePath))
			break;		
	}

	return alterFilePath.u8string();
}

