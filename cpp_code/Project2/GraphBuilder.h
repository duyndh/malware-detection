#pragma once
#include "pch.h"
#include "AsmParser.h"

enum RegisterType
{
	Register_Unknown,

	Register_GeneralA,
	Register_GeneralB,
	Register_GeneralC,
	Register_GeneralD,

	Register_StackPtr,
	Register_StackBasePtr,
	Register_SourceIndex,
	Register_DestinationIndex,

	Register_SegmentStack,
	Register_SegmentCode,
	Register_SegmentData,
	Register_SegmentExtra,
	Register_SegmentF,
	Register_SegmentG
};

struct InstructionNode
{
	InstructionNode(DWORD64 _qwAddress) : qwAddress(_qwAddress), bHasDirectPrev(false), bOpCode(0), dwDirectPrevIndex((MAXDWORD)) { }

	DWORD64 qwAddress;
	BYTE bOpCode; //
	std::string strOpCode;
	std::list<std::string> liRawOperands;
	std::list<RegisterType> liRegisterOperands; //
	std::unordered_set<DWORD> setNextIndex; //
	std::unordered_set<DWORD> setPrevIndex;

	std::unordered_set<DWORD> setNextRetIndex; // Merged later
	std::unordered_set<DWORD> setPrevRetIndex; // Merged later
	DWORD dwDirectPrevIndex; //
	bool bHasDirectPrev;
};

class GraphBuilder
{
private:
	GraphBuilder() {}

	const std::map<std::string, RegisterType> REGISTERS_MAP =
	{
		{ "rax", Register_GeneralA },
		{ "eax", Register_GeneralA },
		{ "ax", Register_GeneralA },
		{ "ah", Register_GeneralA },
		{ "al", Register_GeneralA },

		{ "rbx", Register_GeneralB },
		{ "ebx", Register_GeneralB },
		{ "bx", Register_GeneralB },
		{ "bh", Register_GeneralB },
		{ "bl", Register_GeneralB },

		{ "rcx", Register_GeneralC },
		{ "ecx", Register_GeneralC },
		{ "cx", Register_GeneralC },
		{ "ch", Register_GeneralC },
		{ "cl", Register_GeneralC },

		{ "rdx", Register_GeneralD },
		{ "edx", Register_GeneralD },
		{ "dx", Register_GeneralD },
		{ "dh", Register_GeneralD },
		{ "dl", Register_GeneralD },

		{ "rsp", Register_StackPtr },
		{ "esp", Register_StackPtr },
		{ "sp", Register_StackPtr },
		{ "spl", Register_StackPtr },

		{ "rbp", Register_StackBasePtr },
		{ "ebp", Register_StackBasePtr },
		{ "bp", Register_StackBasePtr },
		{ "bpl", Register_StackBasePtr },

		{ "rsi", Register_SourceIndex },
		{ "esi", Register_SourceIndex },
		{ "si", Register_SourceIndex },
		{ "sil", Register_SourceIndex },

		{ "rdi", Register_DestinationIndex },
		{ "edi", Register_DestinationIndex },
		{ "di", Register_DestinationIndex },
		{ "dil", Register_DestinationIndex },

		{ "ss", Register_SegmentStack },
		{ "cs", Register_SegmentCode },
		{ "ds", Register_SegmentData },
		{ "es", Register_SegmentExtra },
		{ "fs", Register_SegmentF },
		{ "gs", Register_SegmentG },
	};

	const std::set<std::string> m_SET_PSEUDO_OPCODES = PSEUDO_OPCODES;

	std::string m_strFilePath;
	std::vector<InstructionNode> m_vecInstructions;
	std::unordered_map<DWORD64, DWORD> m_mapAddressToIndex;

private:

	void BuildNodes(std::string& strLine);
	std::set<DWORD> LinkJumps();

	void SetDirectPrevForTraceStack(std::stack<DWORD>& stkTrace, DWORD dwIndex);

	void TraceCall(DWORD dwRetIndex, DWORD dwIndex, std::stack<DWORD>& stkTrace, std::set<DWORD>& setTraveledIndex, bool bTracing);
	void LinkRets(const std::set<DWORD>& setRetIndex);
	void MergeRetLinking();

public:
	GraphBuilder(const std::string& strFilePath);

	void Build();
	void PrintGraph();
	void ExportCsv(const std::string& strOutputDirectory);
};
